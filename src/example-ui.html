<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>img2css Example</title>
    <style>
        body {
  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  margin: 0;
  padding: 15px;
  background: #0d1117;
  color: #e6edf3;
  position: relative;
  line-height: 1.5;
  font-size: 14px;
}

.main-header {
  font-size: clamp(2rem, 4vw, 3rem);
  line-height: 1.2;
}

a,
.toggle-stats {
  color: green;
  text-decoration: none;
}

.gradient-background {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100vw;
  height: auto;
  z-index: -1;
  opacity: 0;
  transition: opacity 0.5s ease;
  pointer-events: none;
  mask: radial-gradient(
    ellipse at center,
    black 0%,
    black 25%,
    transparent 60%
  );
  -webkit-mask: radial-gradient(
    ellipse at center,
    black 0%,
    black 25%,
    transparent 60%
  );
}

.gradient-background.active {
  opacity: 0.35;
}

.container {
  background: #161b22;
  padding: clamp(15px, 3vw, 25px);
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3), 0 1px 4px rgba(0, 0, 0, 0.2);
  border: 1px solid #30363d;
  max-width: clamp(300px, 95%, 1200px);
  margin: 0 auto;
}

h1 {
  color: #f0f6fc;
  text-align: center;
  margin-bottom: clamp(15px, 3vw, 25px);
  font-weight: 300;
  font-size: clamp(1.5rem, 3vw, 2.2rem);
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

h1.direction-step {
  margin-top: clamp(2rem, 4vw, 3rem);
  text-align: left;
  color: #1f6feb;
  text-transform: uppercase;
  font-size: clamp(1.5rem, 3vw, 2.5rem);
}

h1.direction-step small {
  text-align: right;
  color: rgba(255, 255, 255, 0.5);
  text-transform: none;
  font-style: italic;
  font-size: clamp(0.9rem, 2vw, 1.1rem);
  display: block;
  margin-top: 0.5rem;
}

h1 small {
  font-size: 0.5em;
}

.upload-section {
  margin-bottom: clamp(15px, 3vw, 25px);
}

.upload-area {
  border: 2px dashed #30363d;
  border-radius: 8px;
  padding: clamp(15px, 3vw, 25px);
  text-align: center;
  margin-bottom: 15px;
  transition: all 0.3s ease;
  background: #0d1117;
  color: #e6edf3;
}

.upload-area:hover {
  border-color: #1f6feb;
  background: #161b22;
}

.upload-area.dragover {
  border-color: #1f6feb;
  background: #21262d;
}

.upload-options {
  display: flex;
  gap: clamp(10px, 2vw, 20px);
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
}

input[type="file"] {
  padding: 8px 12px;
  border: 1px solid #30363d;
  border-radius: 6px;
  background: #21262d;
  color: #e6edf3;
  font-size: 13px;
}

.url-input {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
}

#urlInput {
  padding: 8px 12px;
  border: 1px solid #30363d;
  border-radius: 6px;
  width: clamp(200px, 30vw, 300px);
  font-size: 13px;
  background: #21262d;
  color: #e6edf3;
}

button {
  background: #1f6feb;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.2s;
  box-shadow: 0 2px 6px rgba(31, 111, 235, 0.3), 0 1px 2px rgba(0, 0, 0, 0.2);
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

button:hover {
  background: #388bfd;
  box-shadow: 0 4px 12px rgba(31, 111, 235, 0.4), 0 2px 4px rgba(0, 0, 0, 0.3);
  transform: translateY(-1px);
}

button:disabled {
  background: #484f58;
  cursor: not-allowed;
}

.preview-section {
  margin: clamp(15px, 3vw, 25px) 0;
  display: none;
}

.stats {
  background: #21262d;
  padding: clamp(12px, 2.5vw, 18px);
  border-radius: 8px;
  margin: clamp(12px, 2.5vw, 18px) 0;
  border: 1px solid #30363d;
  border-left: 4px solid #1f6feb;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2), 0 1px 3px rgba(0, 0, 0, 0.1);
}

.stats-content {
  display: block;
}

.stats-detailed {
  display: none;
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #30363d;
}

.toggle-stats {
  margin-top: 8px;
  font-size: clamp(1rem, 2vw, 1.2rem);
  display: inline-block;
  cursor: pointer;
}

.main-row {
  display: grid;
  grid-template-columns: 2fr 1fr;
  gap: clamp(12px, 2.5vw, 20px);
  margin: clamp(15px, 3vw, 20px) 0;
}

.preview-column {
  display: flex;
  flex-direction: column;
}

.side-column {
  display: flex;
  flex-direction: column;
  gap: clamp(12px, 2.5vw, 18px);
}

.original-section {
  display: flex;
  flex-direction: column;
}

.original-section h3,
.preview-column h3 {
  margin: 0 0 10px 0;
  color: #e6edf3;
  font-weight: 500;
  font-size: clamp(1rem, 2vw, 1.2rem);
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
}

.image-container {
  border: 1px solid #30363d;
  border-radius: 8px;
  overflow: hidden;
  background: #21262d;
  transition: transform 0.2s, box-shadow 0.2s;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.image-container.clickable {
  cursor: pointer;
}

.image-container.clickable:hover {
  transform: scale(1.02);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4), 0 4px 12px rgba(0, 0, 0, 0.2);
}

#originalImage,
#gradientPreview {
  max-width: 100%;
  height: auto;
  display: block;
}

.options-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: clamp(12px, 2.5vw, 18px);
  margin: clamp(15px, 3vw, 20px) 0;
  padding: clamp(15px, 3vw, 20px);
  background: #161b22;
  border-radius: 8px;
}

.option-column {
  display: flex;
  flex-direction: column;
  gap: clamp(12px, 2.5vw, 18px);
}

.option-group {
  background: #21262d;
  padding: clamp(12px, 2.5vw, 18px);
  border-radius: 8px;
  border: 1px solid #30363d;
  border-left: 4px solid #1f6feb;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2),
    inset 0 1px 1px rgba(255, 255, 255, 0.03);
}

.option-group label {
  display: block;
  margin-bottom: 6px;
  font-weight: 600;
  color: #e6edf3;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  font-size: 13px;
}

.option-group input[type="range"] {
  width: 100%;
  margin-bottom: 6px;
}

.option-group input[type="text"],
.option-group select {
  width: calc(100% - 16px);
  padding: 8px;
  border: 1px solid #30363d;
  border-radius: 6px;
  margin-bottom: 6px;
  background: #0d1117;
  color: #e6edf3;
  font-size: 13px;
}

.option-group select {
  width: 100%;
}

.help-text {
  font-size: 11px;
  color: #8b949e;
  line-height: 1.3;
}

.checkbox-option {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 10px;
}

.checkbox-option input[type="checkbox"] {
  margin: 0;
}

.optimal-hint {
  font-size: 12px;
  color: #3fb950;
  font-weight: normal;
  margin-left: 8px;
}

.css-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.css-header h3 {
  margin: 0;
  color: #e6edf3;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
}

.switch-container {
  display: flex;
  align-items: center;
  gap: 8px;
}

.switch {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 24px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #484f58;
  transition: 0.4s;
  border-radius: 24px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: 0.4s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: #1f6feb;
}

input:checked + .slider:before {
  transform: translateX(26px);
}

.switch-label {
  font-size: 14px;
  color: #e6edf3;
  font-weight: 500;
}

.spinner-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.spinner {
  width: 50px;
  height: 50px;
  border: 4px solid #30363d;
  border-top: 4px solid #1f6feb;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.css-output {
  margin-top: clamp(15px, 3vw, 25px);
}

.css-code-container {
  position: relative;
}

.css-code {
  background: #0d1117;
  border: 1px solid #30363d;
  border-radius: 8px;
  padding: clamp(12px, 2.5vw, 18px);
  white-space: pre-wrap;
  word-wrap: break-word;
  font-family: "JetBrains Mono", "Fira Code", "Courier New", monospace;
  font-size: clamp(11px, 1.5vw, 13px);
  max-height: clamp(200px, 40vh, 400px);
  overflow-y: auto;
  line-height: 1.4;
  color: #e6edf3;
  transition: all 0.2s ease;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 1px 3px rgba(0, 0, 0, 0.2);
}

.css-code:hover {
  background: #21262d;
}

.copy-button {
  position: absolute;
  top: 12px;
  right: 30px;
  background: #1f6feb;
  color: white;
  border: none;
  width: 36px;
  height: 36px;
  border-radius: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  transition: all 0.2s ease;
  z-index: 10;
  opacity: 0;
  pointer-events: none;
}

.css-code-container:hover .copy-button {
  opacity: 1;
  pointer-events: auto;
}

.copy-button:hover {
  background: #388bfd;
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

.copy-button:active {
  transform: scale(0.95);
}

.copy-button.copied {
  background: #3fb950;
}

.copy-icon {
  display: block;
  pointer-events: none;
  color: white;
  font-size: 18px;
  line-height: 1;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui,
    sans-serif;
}

.optimization-result {
  margin: 20px 0;
  padding: 15px;
  background: #0c3328;
  border-radius: 8px;
  font-size: 14px;
  border-left: 4px solid #3fb950;
  color: #e6edf3;
}

/* Lightbox Modal */
.lightbox {
  display: none;
  position: fixed;
  z-index: 2000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  justify-content: center;
  align-items: center;
}

.lightbox-content {
  max-width: 90%;
  max-height: 90%;
  position: relative;
}

.lightbox img,
.lightbox div {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

.lightbox-close {
  position: absolute;
  top: -40px;
  right: 0;
  color: white;
  font-size: 30px;
  cursor: pointer;
  background: none;
  border: none;
  padding: 0;
}

.resizable-preview {
  position: relative;
  resize: both;
  overflow: hidden;
  min-width: 200px;
  min-height: 150px;
}

.resize-handle {
  position: absolute;
  background: rgba(225, 237, 243, 0.8);
  border: 1px solid #30363d;
}

.resize-handle.corner {
  width: 12px;
  height: 12px;
  border-radius: 2px;
}

.resize-handle.bottom-right {
  bottom: 0;
  right: 0;
  cursor: nw-resize;
}

.resize-handle.bottom-left {
  bottom: 0;
  left: 0;
  cursor: ne-resize;
}

.resize-handle.top-right {
  top: 0;
  right: 0;
  cursor: ne-resize;
}

.resize-handle.top-left {
  top: 0;
  left: 0;
  cursor: nw-resize;
}

@media (max-width: 768px) {
  body {
    padding: 10px;
    font-size: 13px;
  }
  
  .container {
    padding: 15px;
  }

  .main-row {
    grid-template-columns: 1fr;
    gap: 15px;
  }

  .upload-options {
    flex-direction: column;
    gap: 12px;
  }

  #urlInput {
    width: 100%;
    min-width: 250px;
  }

  .options-grid {
    grid-template-columns: 1fr;
    padding: 12px;
    gap: 12px;
  }
  
  .option-group {
    padding: 12px;
  }

  h1.direction-step {
    margin-top: 2rem;
    font-size: 1.5rem;
  }
  
  h1.direction-step small {
    font-size: 0.9rem;
  }
}

@media (max-width: 480px) {
  body {
    padding: 8px;
  }
  
  .container {
    padding: 12px;
  }
  
  .upload-area {
    padding: 15px;
  }
  
  .css-code {
    padding: 12px;
    font-size: 11px;
  }
  
  .main-header {
    font-size: 2rem;
  }
}

    </style>
</head>
<body>
    <div class="container">
  <h1><span class="main-header">img2css</span>
    <p>
      <small>Convert any image to a single css gradient. </small>
    </p>
  </h1>

  <p style="padding: clamp(10px, 2vw, 15px); text-align:center; font-size: clamp(0.9rem, 2vw, 1.1rem); line-height: 1.4;">
    This demo shows the capabilities of the img2css package. For full documentation see <a href="https://github.com/digitalisstudios/img2css" target="_blank">the documentation here</a>
  </p>

  <div class="upload-section">
    <h1 class="direction-step">Step 1. <small>Drop an image, browse for an image or load an image from a url</small></h1>
    <div class="upload-area" id="uploadArea">
      <p>Drag and drop an image here or choose an option below</p>

    </div>

    <div class="upload-options">
      <div>
        <input type="file" id="imageInput" accept="image/*">
      </div>
      <div class="url-input">
        <input type="text" id="urlInput" placeholder="Or enter image URL" value="https://i.imgur.com/Qc3TD8h.jpeg">
        <button id="loadUrlBtn">Load URL</button>
      </div>
    </div>
  </div>

  <div class="spinner-overlay" id="spinnerOverlay">
    <div class="spinner"></div>
  </div>

  <div class="preview-section" id="previewSection">

    <h1 class="direction-step">Step 2. <small> Preview the converted image. (Yes that's actually a css gradient)</small></h1>
    <div class="main-row">
      <div class="preview-column">
        <h3>Pure CSS Preview</h3>
        <div class="image-container">
          <div id="gradientPreview"></div>
        </div>

        <h3 style="margin-top:12px; display: none;">Specular Map Preview</h3>
        <div class="image-container" style="display: none;">
          <div id="specGradientPreview"></div>
        </div>

        

        <div id="albedoPreviewSection" style="display: none;">
          <h3 style="margin-top:12px;">Albedo Map Preview</h3>
          <div class="image-container">
            <img id="albedoImage" alt="Albedo Map" style="max-width:100%; display:block;" />
          </div>
        </div>

        <div id="normalPreviewSection">
          <h3 style="margin-top:12px;">Normal Map Preview</h3>
          <div class="image-container">
            <div id="normalGradientPreview"></div>
          </div>
        </div>

        <div id="roughnessPreviewSection">
          <h3 style="margin-top:12px;">Roughness Map Preview</h3>
          <div class="image-container">
            <div id="roughnessGradientPreview"></div>
          </div>
        </div>

        <div id="subjectnormalPreviewSection">
          <h3 style="margin-top:12px;">Subject Normal Map Preview</h3>
          <div class="image-container">
            <div id="subjectnormalGradientPreview"></div>
          </div>
        </div>

        <div id="irradiancePreviewSection" style="display: none;">
          <h3 style="margin-top:12px;">Irradiance Map Preview</h3>
          <div class="image-container">
            <img id="irradianceImage" alt="Irradiance Map" style="max-width:100%; display:block;" />
          </div>
        </div>

        <div id="depthPreviewSection" style="display: none;">
          <h3 style="margin-top:12px;">Depth Map Preview</h3>
          <div class="image-container">
            <img id="depthImage" alt="Depth Map" style="max-width:100%; display:block;" />
          </div>
        </div>

        <div id="objectPreviewSection" style="display: none;">
          <h3 style="margin-top:12px;">Object Isolation Preview</h3>
          <div class="image-container">
            <img id="objectImage" alt="Object Mask" style="max-width:100%; display:block;" />
          </div>
        </div>
      </div>

      <div class="side-column">
        <div class="original-section">
          <h3>Original (Source image)</h3>
          <div class="image-container">
            <img id="originalImage" alt="Original">
          </div>
        </div>

        <div id="stats" class="stats">
          <div class="stats-content" id="statsContent"></div>
          <div class="stats-detailed" id="statsDetailed"></div>
          <span class="toggle-stats" id="toggleStats">Show detailed stats</span>
        </div>
      </div>
    </div>

    <h1 class="direction-step">Step 3. <small>Fine tune the settings for your gradient in real time</small></h1>
    <div class="options-grid">
      <div class="option-column">
        <div class="option-group">
          <label for="detailsSlider">
            Details: <span id="detailsValue">100</span>%<span id="optimalDetails" class="optimal-hint" style="display: none;"></span>
          </label>
          <input type="range" id="detailsSlider" min="1" max="100" value="100">
          <div class="help-text">
            Higher values preserve more detail
          </div>
        </div>

        <div class="option-group">
          <label for="posterizationStrengthSlider">Posterization: <span id="posterizationStrengthValue">0%</span></label>
          <input type="range" id="posterizationStrengthSlider" min="0" max="100" value="0" step="5">
          <div class="help-text">
            Limit gradients to colors from original image (0% = off, 100% = full posterization)
          </div>
        </div>
      </div>

      <div class="option-column">
        <div class="option-group">
          <label for="compressionSlider">
            Compression: <span id="compressionValue">0</span>%<span id="optimalCompression" class="optimal-hint" style="display: none;"></span>
          </label>
          <input type="range" id="compressionSlider" min="0" max="100" value="-">
          <div class="help-text">
            Higher values reduce file size
          </div>
        </div>
      </div>

      <div class="option-column">
        <div class="option-group">
          <label for="maxSizeInput">Max CSS file size</label>
          <input type="text" id="maxSizeInput" placeholder="e.g., 500KB, 2MB">
        </div>

        <div class="option-group">
          <label for="processingModeSelect">Processing Mode</label>
          <select id="processingModeSelect">
            <option value="auto">Auto (detect orientation)</option>
            <option value="rows">Rows (horizontal gradients)</option>
            <option value="columns">Columns (vertical gradients)</option>
            <option value="hybrid">Hybrid (blend both directions)</option>
          </select>
          <div class="help-text">
            Choose gradient direction manually
          </div>
        </div>

        <div class="option-group">
          <label>Plugins</label>
          <div id="pluginControlsMount"></div>
          <div class="help-text">Enable and configure installed plugins.</div>
        </div>
      </div>
    </div>

    <div class="css-output" id="cssOutput" style="display: none;">
      <h1 class="direction-step">Step 4. <small>Grab your generated gradient</small></h1>
      <div class="css-header">
        <h3>Generated CSS:</h3>
        <div class="switch-container">
          <span class="switch-label">Minify</span>
          <label class="switch">
            <input type="checkbox" id="minifiedCheckbox">
            <span class="slider"></span>
          </label>
        </div>
      </div>
      <div class="css-code-container">
        <div class="css-code" id="cssCode"></div>
        <button id="copyBtn" class="copy-button" title="Copy CSS">
          <span class="copy-icon">⎘</span>
        </button>
      </div>

      <h3 style="margin-top:16px;">Specularity CSS (via Roughness)</h3>
      <div class="css-code-container">
        <div class="css-code" id="specCssCode"></div>
        <button id="specDownloadBtn" class="copy-button" title="Download Specular CSS">
          <span class="copy-icon">⤓</span>
        </button>
      </div>

      <h3 style="margin-top:16px;">Map CSS (Normal)</h3>
      <div class="css-code-container">
        <div class="css-code" id="normalCssCode"></div>
        <button id="normalDownloadBtn" class="copy-button" title="Download Normal CSS">
          <span class="copy-icon">⤓</span>
        </button>
      </div>

      <h3 style="margin-top:16px;">Map CSS (Roughness)</h3>
      <div class="css-code-container">
        <div class="css-code" id="roughCssCode"></div>
        <button id="roughDownloadBtn" class="copy-button" title="Download Roughness CSS">
          <span class="copy-icon">⤓</span>
        </button>
      </div>

      <h3 style="margin-top:16px;">Map CSS (Subject Normal)</h3>
      <div class="css-code-container">
        <div class="css-code" id="subjectnormalCssCode"></div>
        <button id="subjectnormalDownloadBtn" class="copy-button" title="Download Subject Normal CSS">
          <span class="copy-icon">⤓</span>
        </button>
      </div>

      <h3 style="margin-top:16px;">Reflection CSS (via Subject Normal)</h3>
      <div class="css-code-container">
        <div class="css-code" id="reflFromSubjectnormalCssCode"></div>
        <button id="reflFromSubjectnormalDownloadBtn" class="copy-button" title="Download Reflection (via Subject Normal) CSS">
          <span class="copy-icon">⤓</span>
        </button>
      </div>

      <div style="margin-top:12px; text-align:right;">
        <button id="downloadAllBtn" title="Download all generated maps">Download All Maps</button>
      </div>
    </div>
  </div>
</div>

    <script src="plugins/soft-posterize.global.js"></script>
    <script src="plugins/map-extractor.global.js"></script>
    <script src="plugin-ui.js"></script>
    <script src="img2css.js"></script>
    <script>
        class img2cssUI {
        	firstLoad = true;


            constructor(config = {}) {
            	console.log("Initializing img2cssUI with config:", config);
                // Create instance of the core converter
                this.core = new img2css(config);
                
                // Auto-generation timeout
                this.generationTimeout = null;
                
                // Setup UI if DOM elements exist
                if (typeof document !== 'undefined' && document.getElementById('uploadArea')) {
                    this.setupEventListeners();
                }
                
                // If source is provided, load it automatically
                if (this.core.config.source) {
                    this.loadFromSource(this.core.config.source);
                }
            }

            initPluginUI(pluginMount) {
                if (!pluginMount) return;
                // Defer to ensure all plugin globals are available
                const setup = () => {
                    const defs = [];
                    if (window.SoftPosterize && window.SoftPosterize.ui) defs.push({ factory: window.SoftPosterize, ui: window.SoftPosterize.ui });
                    if (window.MapExtractor && window.MapExtractor.ui) {
                        defs.push({ factory: window.MapExtractor, ui: window.MapExtractor.ui });
                    }

                    if (!window.PluginUI) {
                        console.warn('[Plugins] plugin-ui.js not loaded.');
                        pluginMount.innerHTML = '<div class="help-text">No plugins UI available (plugin-ui.js not loaded).</div>';
                        return;
                    }
                    if (!defs.length) {
                        console.warn('[Plugins] No compatible plugins detected.');
                        pluginMount.innerHTML = '<div class="help-text">No compatible plugins detected. Ensure plugin scripts are loaded before this script.</div>';
                        return;
                    }
                    const self = this;
                    this.pluginUI = new window.PluginUI({
                        mount: pluginMount,
                        plugins: defs,
                        hooks: {
                            mapExtractor: {
                                onMapCSS({ type, css }) {
                                    // Route CSS based previews for normal, roughness, and subject normal maps
                                    if (type === 'normal') {
                                        self.updateNormalGradientClass(css);
                                        const normalEl = document.getElementById('normalGradientPreview');
                                        if (normalEl) normalEl.className = 'normal-gradient-preview';
                                        const outN = document.getElementById('normalCssCode'); if (outN) outN.textContent = css;
                                    } else if (type === 'roughness') {
                                        self.updateRoughnessGradientClass(css);
                                        const roughnessEl = document.getElementById('roughnessGradientPreview');
                                        if (roughnessEl) roughnessEl.className = 'roughness-gradient-preview';
                                        const outR = document.getElementById('roughCssCode'); if (outR) outR.textContent = css;
                                        // Also use roughness as specularity CSS
                                        const outSpec = document.getElementById('specCssCode'); if (outSpec) outSpec.textContent = css;
                                    } else if (type === 'subjectnormal') {
                                        self.updateSubjectNormalGradientClass(css);
                                        const subjectnormalEl = document.getElementById('subjectnormalGradientPreview');
                                        if (subjectnormalEl) subjectnormalEl.className = 'subjectnormal-gradient-preview';
                                        const outS = document.getElementById('subjectnormalCssCode'); if (outS) outS.textContent = css;
                                        const outReflS = document.getElementById('reflFromSubjectnormalCssCode'); if (outReflS) outReflS.textContent = css;
                                    }
                                },
                                onMap({ type, dataURL }) {
                                    self.lastMapData = self.lastMapData || {};
                                    self.lastMapData[type] = dataURL || null;
                                    // Only handle image-based previews for maps that don't use CSS gradients
                                    const mapToImg = { albedo: 'albedoImage', irradiance: 'irradianceImage', depth: 'depthImage', object: 'objectImage' };
                                    const imgId = mapToImg[type];
                                    if (imgId) {
                                        const img = document.getElementById(imgId);
                                        if (img && dataURL) {
                                            img.src = dataURL;
                                        }
                                    }
                                }
                            }
                        },
                        onChange: () => { 
                            this.updateMapPreviewVisibility(); 
                            this.updateStats(); 
                            this.scheduleGeneration(); 
                        }
                    });
                    
                    // Set initial preview visibility based on default values
                    setTimeout(() => this.updateMapPreviewVisibility(), 0);
                };
                if (document.readyState === 'complete') setTimeout(setup, 0);
                else setTimeout(setup, 0);
            }

            // Delegate to core for CSS generation
            async generateCSS(imageSource, options = {}) {
                // Update core config with options first
                Object.assign(this.core.config, options);
                this.core.config.source = imageSource;
                
                // Generate CSS and return full result object for UI compatibility
                const css = await this.core.toCSS();
                return this.core.stats; // Return the detailed stats the UI expects
            }

            // Get imageData property from core
            get imageData() {
                return this.core.imageData;
            }

            // Delegate utility methods to core
            formatFileSize(sizeKB) {
                return this.core.formatFileSize(sizeKB);
            }

            parseMaxSizeToKB(maxSizeStr) {
                return this.core.parseMaxSizeToKB(maxSizeStr);
            }

            estimateCSSSize(width, height, details, compression) {
                return this.core.estimateCSSSize(width, height, details, compression);
            }

            calculateImageComplexity(data, width, height) {
                return this.core.calculateImageComplexity(data, width, height);
            }

            /*
            async findOptimalSettingsForImage(preserveParameter = null) {
                return await this.core.core.findOptimalSettingsForImage(preserveParameter);
            }
            */

            // === UI-Related Methods (only work when DOM is available) ===

            setupEventListeners() {
                const elements = {
                    uploadArea: document.getElementById('uploadArea'),
                    imageInput: document.getElementById('imageInput'),
                    urlInput: document.getElementById('urlInput'),
                    loadUrlBtn: document.getElementById('loadUrlBtn'),
                    copyBtn: document.getElementById('copyBtn'),
                    detailsSlider: document.getElementById('detailsSlider'),
                    detailsValue: document.getElementById('detailsValue'),
                    compressionSlider: document.getElementById('compressionSlider'),
                    compressionValue: document.getElementById('compressionValue'),
                    maxSizeInput: document.getElementById('maxSizeInput'),
                    minifiedCheckbox: document.getElementById('minifiedCheckbox'),
                    processingModeSelect: document.getElementById('processingModeSelect'),
                    originalPaletteCheckbox: document.getElementById('originalPaletteCheckbox'),
                    toggleStats: document.getElementById('toggleStats')
                };

                let firstLoad = true;

                
                elements.uploadArea.addEventListener('click', (e) => {
                    if (e.target !== elements.imageInput) {
                        elements.imageInput.click();
                    }
                });
                elements.uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
                elements.uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                elements.uploadArea.addEventListener('drop', (e) => this.handleDrop(e));
                
                elements.imageInput.addEventListener('change', (e) => this.handleFileSelect(e));
                elements.loadUrlBtn.addEventListener('click', () => this.loadFromUrl());
                elements.copyBtn.addEventListener('click', () => this.copyCSS());
                const specDl = document.getElementById('specDownloadBtn');
                if (specDl) specDl.addEventListener('click', () => this.downloadMapCSS('specular'));
                const normalDl = document.getElementById('normalDownloadBtn');
                if (normalDl) normalDl.addEventListener('click', () => this.downloadMapCSS('normal'));
                const roughDl = document.getElementById('roughDownloadBtn');
                if (roughDl) roughDl.addEventListener('click', () => this.downloadMapCSS('roughness'));
                const subjNormDl = document.getElementById('subjectnormalDownloadBtn');
                if (subjNormDl) subjNormDl.addEventListener('click', () => this.downloadMapCSS('subjectnormal'));
                const reflFromSubjDl = document.getElementById('reflFromSubjectnormalDownloadBtn');
                if (reflFromSubjDl) reflFromSubjDl.addEventListener('click', () => this.downloadMapCSS('reflViaSubjectnormal'));
                const allBtn = document.getElementById('downloadAllBtn');
                if (allBtn) allBtn.addEventListener('click', () => this.downloadAllMaps());
                elements.toggleStats.addEventListener('click', () => this.toggleDetailedStats());
                
                elements.detailsSlider.addEventListener('input', (e) => {
                    elements.detailsValue.textContent = e.target.value;
                    this.updateStats();
                    this.scheduleGeneration();
                    
                    setTimeout(async () => {
                        if (await this.autoAdjustForMaxSize('details')) {
                            this.updateStats();
                        }
                    }, 100);
                });
                
                elements.compressionSlider.addEventListener('input', (e) => {
                    elements.compressionValue.textContent = e.target.value;
                    this.updateStats();
                    this.scheduleGeneration();
                    
                    setTimeout(async () => {
                        if (await this.autoAdjustForMaxSize('compression')) {
                            this.updateStats();
                        }
                    }, 100);
                });
                
                elements.maxSizeInput.addEventListener('input', () => {
                    this.updateStats();
                    this.scheduleGeneration();
                    
                    if (this.imageData && elements.maxSizeInput.value.trim()) {
                        setTimeout(() => this.core.findOptimalSettings(), 500);
                    }
                });
                
                elements.minifiedCheckbox.addEventListener('change', () => {
                    this.updateStats();
                    this.scheduleGeneration();
                });
                
                elements.processingModeSelect.addEventListener('change', () => {
                    this.updateStats();
                    this.scheduleGeneration();
                });
                
                
                const posterizationStrengthSlider = document.getElementById('posterizationStrengthSlider');
                const posterizationStrengthValue = document.getElementById('posterizationStrengthValue');
                
                posterizationStrengthSlider.addEventListener('input', () => {
                    posterizationStrengthValue.textContent = posterizationStrengthSlider.value + '%';
                    this.updateStats();
                    this.scheduleGeneration();
                });
                
                // Set initial values from config
                if (this.core.config.processing.details !== 100) {
                    elements.detailsSlider.value = this.core.config.processing.details;
                    elements.detailsValue.textContent = this.core.config.processing.details;
                }
                
                if (this.core.config.processing.compression !== 15) {
                    elements.compressionSlider.value = this.core.config.processing.compression;
                    elements.compressionValue.textContent = this.core.config.processing.compression;
                }
                
                if (this.core.config.maxSize) {
                    elements.maxSizeInput.value = this.core.config.maxSize;
                }

                // Auto-render plugin controls if available
                const pluginMount = document.getElementById('pluginControlsMount') || (function(){
                  const grids = document.getElementsByClassName('options-grid');
                  if (grids.length) {
                    const mountWrap = document.createElement('div');
                    mountWrap.className = 'option-column';
                    const hdr = document.createElement('h3'); hdr.textContent = 'Plugins'; hdr.style.margin = '0 0 10px';
                    mountWrap.appendChild(hdr);
                    const mount = document.createElement('div'); mount.id = 'pluginControlsMount';
                    mountWrap.appendChild(mount);
                    grids[0].appendChild(mountWrap);
                    return mount;
                  }
                  return null;
                })();
                this.initPluginUI(pluginMount);
            }

            scheduleGeneration() {
                // Clear existing timeout
                if (this.generationTimeout) {
                    clearTimeout(this.generationTimeout);
                }
                
                // Schedule new generation with 1 second delay
                this.generationTimeout = setTimeout(() => {
                    if (this.imageData) {
                        this.generateGradient();
                        if (this.firstLoad) {
							//this.firstLoad = false;
							var that = this;;
							this.findOptimalSettings().then(() => {
								that.firstLoad = false;
							});
						}

                    }
                }, 1000);
            }

            showSpinner() {
                document.getElementById('spinnerOverlay').style.display = 'flex';
            }

            hideSpinner() {
                document.getElementById('spinnerOverlay').style.display = 'none';
            }

            toggleDetailedStats() {
                const detailed = document.getElementById('statsDetailed');
                const toggle = document.getElementById('toggleStats');
                
                if (detailed.style.display === 'none' || !detailed.style.display) {
                    detailed.style.display = 'block';
                    toggle.textContent = 'Hide detailed stats';
                } else {
                    detailed.style.display = 'none';
                    toggle.textContent = 'Show detailed stats';
                }
            }

            loadFromUrl() {
                const url = document.getElementById('urlInput').value.trim();
                if (!url) return;
                
                this.showSpinner();
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    this.hideSpinner();
                    this.processImage(img);
                    this.showPreview(url);
                    this.applyAutoOptimizationIfNeeded();
                };
                img.onerror = () => {
                    this.hideSpinner();
                    alert('Failed to load image from URL. Please check the URL and try again.');
                };
                img.src = url;
            }

            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.add('dragover');
            }
            
            handleDragLeave(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
            }
            
            handleDrop(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.loadImage(files[0]);
                }
            }
            
            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.loadImage(file);
                }
            }
            
            loadImage(file) {
                if (!file.type.startsWith('image/')) {
                    alert('Please select a valid image file.');
                    return;
                }
                
                this.showSpinner();
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.hideSpinner();
                        this.processImage(img);
                        this.showPreview(e.target.result);
                        this.applyAutoOptimizationIfNeeded();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            loadFromSource(source) {
                if (typeof source === 'string') {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        this.processImage(img);
                        this.showPreview(source);
                        this.applyAutoOptimizationIfNeeded();
                    };
                    img.onerror = () => {
                        console.error('Failed to load image from URL:', source);
                    };
                    img.src = source;
                } else if (source instanceof File) {
                    this.loadImage(source);
                } else {
                    console.error('Invalid source provided. Must be URL string or File object.');
                }
            }
            
            applyAutoOptimizationIfNeeded() {
                // Only run auto-optimization if not skipped in config
                if (this.core.config.autoOptimize == true) {
                    this.findOptimalSettings();
                }
                // Always trigger initial CSS generation
                this.scheduleGeneration();
            }
            
            showPreview(imageSrc) {
                document.getElementById('previewSection').style.display = 'block';
                document.getElementById('originalImage').src = imageSrc;
            }
            
            processImage(img) {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                
                ctx.drawImage(img, 0, 0);
                const rawImageData = ctx.getImageData(0, 0, img.width, img.height);
                
                this.core.imageData = {
                    width: img.width,
                    height: img.height,
                    data: rawImageData.data
                };
                
                this.core.canvas = canvas;
                this.core.ctx = ctx;
                
                this.showStats(img.width, img.height);
                this.updateStats();
            }

            generateGradient() {
                if (!this.imageData) return;
                
                const { width, height, data } = this.imageData;
                this.showSpinner();
                
                setTimeout(() => {
                    this.processGradient(width, height, data);
                }, 100);
            }
            
            async processGradient(width, height, data) {
                const details = parseInt(document.getElementById('detailsSlider').value);
                const compression = parseInt(document.getElementById('compressionSlider').value);
                const minified = document.getElementById('minifiedCheckbox').checked;
                const processingMode = document.getElementById('processingModeSelect').value;
                const posterize = parseFloat(document.getElementById('posterizationStrengthSlider').value) / 100;
                const useOriginalPalette = posterize > 0;
                
                try {
                    // Update the core config with current settings
                    this.core.config.selector = '.slick-img-gradient';
                    this.core.config.processing.details = details;
                    this.core.config.processing.compression = compression;
                    this.core.config.processing.mode = processingMode;
                    this.core.config.processing.posterize = posterize;
                    this.core.config.processing.useOriginalPalette = useOriginalPalette;
                    this.core.config.minified = minified;
                    
                    // Set the image data directly
                    this.core.imageData = { width, height, data };
                    
                    // Configure plugins from PluginUI if available
                    if (this.pluginUI) {
                        this.core.config.plugins = this.pluginUI.build();
                    } else {
                        this.core.config.plugins = [];
                    }
                    
                    // Use the new API
                    const css = await this.core.toCSS();
                    
                    this.createGradientPreview(css, width, height);
                    this.updateBodyBackground(css, width, height);
                    
                    document.getElementById('cssCode').textContent = css;
                    document.getElementById('cssOutput').style.display = 'block';
                    this.hideSpinner();
                } catch (error) {
                    console.error('Error generating gradient:', error);
                    this.hideSpinner();
                    alert('Error generating gradient: ' + error.message);
                }
            }

            createGradientPreview(cssClass, width, height) {
                const preview = document.getElementById('gradientPreview');
                
                // Update the shared CSS class instead of inline styles
                this.updateSharedGradientClass(cssClass);
                preview.className = 'slick-img-gradient';
                
                // Clear any inline styles
                preview.style.width = '';
                preview.style.height = '';
                preview.style.aspectRatio = '';
                preview.style.maxWidth = '';
                preview.style.display = 'block';
                preview.style.border = 'none';
                preview.style.borderRadius = '4px';
                preview.style.maxWidth = '100%';
                preview.style.background = '';
                preview.style.backgroundSize = '';
                preview.style.backgroundRepeat = '';
                preview.style.backgroundPosition = '';
            }

            updateSharedGradientClass(cssClass) {
                // Update or create the shared CSS class for both preview and background
                let styleElement = document.getElementById('shared-gradient-style');
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = 'shared-gradient-style';
                    document.head.appendChild(styleElement);
                }
                
                styleElement.textContent = cssClass;
            }

            updateSpecGradientClass(cssClass) {
                // Update or create the specular map CSS class
                let styleElement = document.getElementById('spec-map-style');
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = 'spec-map-style';
                    document.head.appendChild(styleElement);
                }
                
                styleElement.textContent = cssClass;
            }

            

            updateNormalGradientClass(cssClass) {
                // Update or create the normal map CSS class
                let styleElement = document.getElementById('normal-map-style');
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = 'normal-map-style';
                    document.head.appendChild(styleElement);
                }
                
                // Extract aspect ratio from the CSS and apply it to the preview div
                const aspectRatioMatch = cssClass.match(/aspect-ratio:\s*(\d+)\s*\/\s*(\d+)/);
                if (aspectRatioMatch) {
                    const ratio = `${aspectRatioMatch[1]} / ${aspectRatioMatch[2]}`;
                    const normalDiv = document.getElementById('normalGradientPreview');
                    if (normalDiv) {
                        normalDiv.style.aspectRatio = ratio;
                    }
                }
                
                styleElement.textContent = cssClass;
            }

            updateRoughnessGradientClass(cssClass) {
                // Update or create the roughness map CSS class
                let styleElement = document.getElementById('roughness-map-style');
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = 'roughness-map-style';
                    document.head.appendChild(styleElement);
                }
                
                // Extract aspect ratio from the CSS and apply it to the preview div
                const aspectRatioMatch = cssClass.match(/aspect-ratio:\s*(\d+)\s*\/\s*(\d+)/);
                if (aspectRatioMatch) {
                    const ratio = `${aspectRatioMatch[1]} / ${aspectRatioMatch[2]}`;
                    const roughnessDiv = document.getElementById('roughnessGradientPreview');
                    if (roughnessDiv) {
                        roughnessDiv.style.aspectRatio = ratio;
                    }
                }
                
                styleElement.textContent = cssClass;
            }

            updateSubjectNormalGradientClass(cssClass) {
                // Update or create the subject normal map CSS class
                let styleElement = document.getElementById('subjectnormal-map-style');
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = 'subjectnormal-map-style';
                    document.head.appendChild(styleElement);
                }
                
                // Extract aspect ratio from the CSS and apply it to the preview div
                const aspectRatioMatch = cssClass.match(/aspect-ratio:\s*(\d+)\s*\/\s*(\d+)/);
                if (aspectRatioMatch) {
                    const ratio = `${aspectRatioMatch[1]} / ${aspectRatioMatch[2]}`;
                    const subjectnormalDiv = document.getElementById('subjectnormalGradientPreview');
                    if (subjectnormalDiv) {
                        subjectnormalDiv.style.aspectRatio = ratio;
                    }
                }
                
                styleElement.textContent = cssClass;
            }

            updateMapPreviewVisibility() {
                // Update visibility of map preview sections based on plugin control states
                if (!this.pluginUI) return;
                
                try {
                    // Get current plugin values
                    const pluginValues = this.pluginUI.getValues();
                    const mapExtractorValues = pluginValues.mapExtractor || {};
                    
                    // Map of control keys to preview section IDs (only for visible controls)
                    const previewSections = {
                        'normalOn': 'normalPreviewSection', 
                        'roughnessOn': 'roughnessPreviewSection',
                        'subjectnormalOn': 'subjectnormalPreviewSection'
                    };
                    
                    // Update visibility for each section
                    Object.keys(previewSections).forEach(controlKey => {
                        const sectionId = previewSections[controlKey];
                        const section = document.getElementById(sectionId);
                        if (section) {
                            const isEnabled = mapExtractorValues[controlKey] === true;
                            section.style.display = isEnabled ? 'block' : 'none';
                        }
                    });
                    
                    // Hide disabled preview sections permanently
                    const disabledSections = ['albedoPreviewSection', 'depthPreviewSection', 'objectPreviewSection', 'irradiancePreviewSection'];
                    disabledSections.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                            section.style.display = 'none';
                        }
                    });
                } catch (e) {
                    console.warn('Error updating map preview visibility:', e);
                }
            }

            updateBodyBackground(css, width, height) {
                // The CSS class is already updated by updateSharedGradientClass
                // We just need to create/activate the background element
                
                // Create or get the gradient background element
                let gradientEl = document.getElementById('gradient-background');
                if (!gradientEl) {
                    gradientEl = document.createElement('div');
                    gradientEl.id = 'gradient-background';
                    gradientEl.className = 'gradient-background slick-img-gradient';
                    document.body.appendChild(gradientEl);
                } else {
                    // Ensure it has the gradient class
                    gradientEl.className = 'gradient-background slick-img-gradient';
                }
                
                console.log('Background element updated with shared CSS class');
                
                // Activate the background
                gradientEl.classList.add('active');
            }

            
            async findOptimalSettings(preserveParameter = null) {
                try {
                    const maxSizeInput = document.getElementById('maxSizeInput');
                    const maxSizeText = maxSizeInput ? maxSizeInput.value.trim() : '';
                    
                    if (maxSizeText) {
                        this.core.config.maxSize = maxSizeText;
                    } else {
                        this.core.config.maxSize = null;
                    }
                    
                    const optimal = await this.core.findOptimalSettingsForImage(preserveParameter);
                    this.displayOptimizationResults(optimal);
                } catch (error) {
                    console.error('Optimization error:', error);
                }
            }
            
            displayOptimizationResults(optimal) {
                const detailsSlider = document.getElementById('detailsSlider');
                const detailsValue = document.getElementById('detailsValue');
                const compressionSlider = document.getElementById('compressionSlider');
                const compressionValue = document.getElementById('compressionValue');
                
                // Update sliders
                if(!this.firstLoad){
					detailsSlider.value = optimal.details;
	                detailsValue.textContent = optimal.details;
	                compressionSlider.value = optimal.compression;
	                compressionValue.textContent = optimal.compression;
	                this.updateStats();
				}

                
                
                // Show optimal hints inline
                this.showOptimalHints(optimal.details, optimal.compression);
            }
            
            showOptimalHints(optimalDetails, optimalCompression) {
                const detailsHint = document.getElementById('optimalDetails');
                const compressionHint = document.getElementById('optimalCompression');
                
                detailsHint.textContent = `(optimal: ${optimalDetails}%)`;
                detailsHint.style.display = 'inline';
                
                compressionHint.textContent = `(optimal: ${optimalCompression}%)`;
                compressionHint.style.display = 'inline';
                
                // Keep hints visible permanently
            }

            updateStats() {
                if (!this.imageData) return;
                const details = parseInt(document.getElementById('detailsSlider').value);
                const { width, height } = this.imageData;
                this.showStats(width, height, details);
            }

            showStats(width, height, details = 100) {
                const pixels = width * height;
                const compression = parseInt(document.getElementById('compressionSlider').value);
                
                // Calculate scaled dimensions
                const scaleFactor = details / 100;
                const scaledWidth = scaleFactor >= 1.0 ? width : Math.max(1, Math.round(width * scaleFactor));
                const scaledHeight = scaleFactor >= 1.0 ? height : Math.max(1, Math.round(height * scaleFactor));
                
                // Determine orientation
                const isLandscape = width > height;
                const orientation = isLandscape ? 'Landscape' : 'Portrait';
                
                // Calculate total reduction
                const baseSamplingRate = 100 / details;
                const baseReduction = (compression / 100) * 0.6;
                const adjustedSamplingRate = baseSamplingRate * (1 + baseReduction);
                const sampledPixels = Math.ceil(scaledWidth / adjustedSamplingRate) * Math.ceil(scaledHeight / adjustedSamplingRate);
                const totalReduction = ((pixels - sampledPixels) / pixels * 100).toFixed(1);
                
                // Get CSS size estimate
                const minified = document.getElementById('minifiedCheckbox').checked;
                const cssEstimate = this.estimateCSSSize(width, height, details, compression, minified);
                
                // Basic stats
                const scalingInfo = scaleFactor < 1.0 ? 
                    `${scaledWidth} × ${scaledHeight} pixels` : 'Not scaled';
                
                document.getElementById('statsContent').innerHTML = `
                    <strong>Dimensions:</strong> ${width} × ${height} pixels (${pixels.toLocaleString()} total)<br>
                    <strong>Scaled for Processing:</strong> ${scalingInfo}<br>
                    <strong>Orientation:</strong> ${orientation}<br>
                    <strong>Total Reduction:</strong> ${totalReduction}%<br>
                    <strong>Estimated Size:</strong> ${this.formatFileSize(cssEstimate.cssSizeKB)}
                `;
                
                // Detailed stats (initially hidden)
                const useRows = isLandscape;
                const modeText = useRows ? 'rows' : 'columns';
                const gradientDirection = useRows ? 'horizontal' : 'vertical';
                
                const baseBlur = 2;
                const exponentialFactor = Math.pow(adjustedSamplingRate, 0.5);
                const blurRadius = Math.max(1, Math.floor(baseBlur * exponentialFactor));
                
                const uniqueStripes = useRows ? 
                    Math.ceil(scaledHeight / adjustedSamplingRate) : 
                    Math.ceil(scaledWidth / adjustedSamplingRate);
                
                const colorThreshold = (compression / 100) * 30;
                const baseColorStops = uniqueStripes * (useRows ? 
                    Math.ceil(scaledWidth / adjustedSamplingRate) : 
                    Math.ceil(scaledHeight / adjustedSamplingRate));
                
                const complexityFactor = Math.min(width, height) > 500 ? 1.2 : 1.0;
                const colorOptimizationPercent = compression === 0 ? 0 : 
                    Math.min(60, (compression / 100) * 50 * complexityFactor);
                const finalColorStops = Math.round(baseColorStops * (1 - colorOptimizationPercent / 100));
                
                document.getElementById('statsDetailed').innerHTML = `
                    <strong>Processing Details:</strong><br>
                    Base sampling: Every ${baseSamplingRate.toFixed(1)} pixels<br>
                    2D Gaussian blur: ${blurRadius}px radius<br>
                    Processing mode: ${modeText} (${gradientDirection} gradients)<br>
                    Adjusted sampling rate: 1:${adjustedSamplingRate.toFixed(1)}<br><br>
                    
                    <strong>Compression Analysis:</strong><br>
                    ${modeText.charAt(0).toUpperCase() + modeText.slice(1)} reduction: ${(baseReduction * 100).toFixed(1)}%<br>
                    Color threshold: ${colorThreshold.toFixed(1)} RGB units<br>
                    Color optimization: ${colorOptimizationPercent.toFixed(1)}%<br><br>
                    
                    <strong>Output Estimation:</strong><br>
                    Estimated ${modeText}: ${uniqueStripes.toLocaleString()}<br>
                    Before color optimization: ~${baseColorStops.toLocaleString()} color stops<br>
                    After color optimization: ~${finalColorStops.toLocaleString()} color stops<br>
                    CSS method: ${useRows ? 'Row-based processing' : 'Column-based processing'}
                `;
            }

            copyCSS() {
                const cssCode = document.getElementById('cssCode').textContent;
                navigator.clipboard.writeText(cssCode).then(() => {
                    const btn = document.getElementById('copyBtn');
                    const icon = btn.querySelector('.copy-icon');
                    
                    // Add copied class for visual feedback
                    btn.classList.add('copied');
                    btn.title = 'Copied!';
                    
                    // Change to checkmark
                    icon.textContent = '✓';
                    
                    setTimeout(() => {
                        btn.classList.remove('copied');
                        btn.title = 'Copy CSS';
                        // Change back to copy icon
                        icon.textContent = '⎘';
                    }, 2000);
                }).catch(() => {
                    alert('Failed to copy to clipboard. Please select and copy manually.');
                });
            }
            
            async autoAdjustForMaxSize(preserveSlider = null) {
                if (!this.imageData) return false;
                
                const maxSizeInput = document.getElementById('maxSizeInput');
                const maxSizeText = maxSizeInput ? maxSizeInput.value.trim() : '';
                
                if (!maxSizeText) return false;
                
                this.core.config.maxSize = maxSizeText;
                const maxSizeKB = this.parseMaxSizeToKB(maxSizeText);
                
                if (!maxSizeKB || maxSizeKB <= 0) return false;
                
                const { width, height } = this.imageData;
                const currentDetails = parseInt(document.getElementById('detailsSlider').value);
                const currentCompression = parseInt(document.getElementById('compressionSlider').value);
                
                const currentSize = this.estimateCSSSize(width, height, currentDetails, currentCompression).cssSizeKB;
                
                if (currentSize <= maxSizeKB) return false;
                
                if (preserveSlider === 'details') {
                    for (let compression = currentCompression; compression <= 100; compression += 1) {
                        const testSize = this.estimateCSSSize(width, height, currentDetails, compression).cssSizeKB;
                        if (testSize <= maxSizeKB) {
                            if (compression !== currentCompression) {
                                document.getElementById('compressionSlider').value = compression;
                                document.getElementById('compressionValue').textContent = compression;
                                return true;
                            }
                            return false;
                        }
                    }
                    return false;
                }
                
                if (preserveSlider === 'compression') {
                    for (let details = currentDetails; details >= 1; details -= 1) {
                        const testSize = this.estimateCSSSize(width, height, details, currentCompression).cssSizeKB;
                        if (testSize <= maxSizeKB) {
                            if (details !== currentDetails) {
                                document.getElementById('detailsSlider').value = details;
                                document.getElementById('detailsValue').textContent = details;
                                return true;
                            }
                            return false;
                        }
                    }
                    return false;
                }
                
                return false;
            }

            copyCSS() {
                const cssCode = document.getElementById('cssCode').textContent;
                if (!cssCode) {
                    alert('No CSS to copy. Please generate a gradient first.');
                    return;
                }
                
                navigator.clipboard.writeText(cssCode).then(() => {
                    // Temporarily change button text
                    const btn = document.getElementById('copyBtn');
                    const originalText = btn.textContent;
                    btn.textContent = 'Copied!';
                    setTimeout(() => {
                        btn.textContent = originalText;
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy CSS: ', err);
                    // Fallback - select the text
                    const cssElement = document.getElementById('cssCode');
                    const range = document.createRange();
                    range.selectNode(cssElement);
                    window.getSelection().removeAllRanges();
                    window.getSelection().addRange(range);
                    alert('CSS selected. Please copy manually with Ctrl+C or Cmd+C');
                });
            }

            downloadMapCSS(mapType) {
                let cssCode = '', filename = '';
                if (mapType === 'specular') {
                    cssCode = document.getElementById('specCssCode').textContent;
                    filename = 'specularity-from-roughness.css';
                } else if (mapType === 'normal') {
                    cssCode = document.getElementById('normalCssCode').textContent;
                    filename = 'normal-map.css';
                } else if (mapType === 'roughness') {
                    cssCode = document.getElementById('roughCssCode').textContent;
                    filename = 'roughness-map.css';
                } else if (mapType === 'subjectnormal') {
                    cssCode = document.getElementById('subjectnormalCssCode').textContent;
                    filename = 'subject-normal-map.css';
                } else if (mapType === 'reflViaSubjectnormal') {
                    cssCode = document.getElementById('reflFromSubjectnormalCssCode').textContent;
                    filename = 'reflection-from-subjectnormal.css';
                } else {
                    alert('Unknown map type: ' + mapType);
                    return;
                }
                
                if (!cssCode) {
                    alert(`No ${mapType} CSS to download. Please generate a gradient first and ensure the ${mapType} map is enabled.`);
                    return;
                }
                
                const blob = new Blob([cssCode], { type: 'text/css' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            downloadAllMaps() {
                // Collect all available map CSS
                const maps = [];
                
                const specCSS = document.getElementById('specCssCode').textContent;
                if (specCSS) maps.push({ name: 'specularity-from-roughness.css', content: specCSS });
                
                const normalCSS = document.getElementById('normalCssCode').textContent;
                if (normalCSS) maps.push({ name: 'normal-map.css', content: normalCSS });

                const roughCSS = document.getElementById('roughCssCode').textContent;
                if (roughCSS) maps.push({ name: 'roughness-map.css', content: roughCSS });

                const subjNormCSS = document.getElementById('subjectnormalCssCode').textContent;
                if (subjNormCSS) maps.push({ name: 'subject-normal-map.css', content: subjNormCSS });
                const reflViaSubjCSS = document.getElementById('reflFromSubjectnormalCssCode').textContent;
                if (reflViaSubjCSS) maps.push({ name: 'reflection-from-subjectnormal.css', content: reflViaSubjCSS });
                
                const mainCSS = document.getElementById('cssCode').textContent;
                if (mainCSS) maps.push({ name: 'main-gradient.css', content: mainCSS });
                
                if (maps.length === 0) {
                    alert('No CSS maps to download. Please generate gradients first.');
                    return;
                }
                
                // Download each map
                maps.forEach(map => {
                    const blob = new Blob([map.content], { type: 'text/css' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = map.name;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
            }
        }
        
       
        
        document.addEventListener('DOMContentLoaded', () => {
            window.converter = new img2cssUI({

            	/* DO NOT DELETE COMMENTED OUT OPTIONS - USED FOR TESTING */
                
                /*
                source: 'https://i.imgur.com/Qc3TD8h.jpeg',
				compression: 0,
                details: 80
                */


                source: 'https://i.imgur.com/QFnqULE.png',
                //autoOptimize: false,
                compression: 0,
                details: 48
            });
        });
        
        
    </script>
</body>
</html>
