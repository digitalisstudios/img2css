<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>img2css Example</title>
    <style>
    	* {
    		box-sizing: border-box;

    	}
        body {
  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  margin: 0;
  padding: 0;
  background: #0a0f14;
  color: #e6edf3;
  position: relative;
  line-height: 1.5;
  font-size: 14px;
  overflow: hidden;
  height: 100vh;
  width: 100vw;

}

.app-layout {
  display: grid;
  grid-template-rows: auto 1fr;
  height: 100vh;
}

.fixed-header {
  background: #0b1118;
  border-bottom: 2px solid #243041;
  padding: 15px 20px;
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 30px;
  align-items: center;
  z-index: 1000;
}

.main-content {
  display: grid;
  grid-template-columns: 1fr 890px;
  height: calc(100vh - 70px);
}

.preview-area {
  padding: 40px;
  overflow-y: auto;
  background: #0a0f14;
}

.controls-sidebar {
  background: #0b1118;
  border-left: 2px solid #243041;
  overflow-y: auto;
  padding: 40px;
}

.header-title h1 {
  color: #4CAF50;
  margin: 0;
  font-size: 20px;
}

.header-title p {
  color: #999;
  margin: 5px 0 0 0;
  font-size: 12px;
  text-align: center;
}

.header-title p a {
  color: #2ea043;
  text-decoration: none;
}

.header-title p a:hover {
  text-decoration: underline;
}

.header-upload {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

.compact-file-input {
  background: #333;
  color: white;
  border: 1px solid #555;
  padding: 8px 15px;
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
}

.compact-generate-btn {
  background: #4CAF50;
  color: white;
  border: none;
  padding: 8px 15px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  white-space: nowrap;
}

.compact-generate-btn:hover {
  background: #45a049;
}

.header-stats {
  font-size: 11px;
  color: #999;
  text-align: right;
  min-width: 200px;
}

.header-stats .stat-line {
  margin: 2px 0;
}

.control-tabs {
  display: flex;
  margin-bottom: 15px;
  border-bottom: 1px solid #30363d;
}

.control-tab {
  background: none;
  border: none;
  color: #8b949e;
  padding: 10px 15px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  border-bottom: 2px solid transparent;
  transition: all 0.2s;
}

.control-tab:hover {
  color: #e6edf3;
  background: rgba(255, 255, 255, 0.05);
}

.control-tab.active {
  color: #1f6feb;
  border-bottom-color: #1f6feb;
}

.control-tab-icon {
  font-size: 16px;
}

.control-panel {
  display: none;
}

.control-panel.active {
  display: block;
}

.plugin-container {
  position: relative;
  background: #21262d;
  border-radius: 8px;
  border: 1px solid #30363d;
  border-left: 4px solid #1f6feb;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2), inset 0 1px 1px rgba(255, 255, 255, 0.03);
  margin-bottom: 1.5em;
  transition: all 0.3s ease;
}

.plugin-header {
	--blue-ui-color:#1f6feb;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 18px;
  cursor: pointer;
  border-bottom: 1px solid #1f6feb;
  background: rgba(from var(--blue-ui-color) r g b / 0.25);
  border-radius: 8px 8px 0 0;

}

.plugin-title {
  font-weight: 600;
  color: #e6edf3;
  font-size: 14px;
  margin: 0;
}

.plugin-toggle-container {
  display: flex;
  align-items: center;
  gap: 8px;
}

.plugin-collapse-icon {
  color: #8b949e;
  font-size: 12px;
  transition: transform 0.3s ease;
}

.plugin-container.collapsed .plugin-collapse-icon {
  transform: rotate(-90deg);
}

.plugin-content {
  padding: 18px;
  transition: all 0.3s ease;
  overflow: hidden;
}

.plugin-container.collapsed .plugin-content {
  max-height: 0;
  padding-top: 0;
  padding-bottom: 0;
  opacity: 0;
}

.plugin-container:not(.collapsed) .plugin-content {
  opacity: 1;
}

.plugin-content label {
  display: block;
  margin-bottom: 6px;
  font-weight: 600;
  color: #e6edf3;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  font-size: 13px;
}

.plugin-content input[type="range"] {
  width: 100%;
  margin-bottom: 12px;
}

.plugin-content input[type="text"],
.plugin-content select {
  width: 100%;
  padding: 8px;
  border: 1px solid #30363d;
  border-radius: 6px;
  margin-bottom: 12px;
  background: #0d1117;
  color: #e6edf3;
  font-size: 13px;
}

.plugin-content .switch {
  margin-bottom: 12px;
}

.plugin-content .help-text {
  font-size: 11px;
  color: #8b949e;
  line-height: 1.3;
  margin-bottom: 12px;
}

.plugin-content > div {
  margin-bottom: 12px;
}

.plugin-content > div:last-child {
  margin-bottom: 0;
}

.main-header {
  font-size: clamp(2rem, 4vw, 3rem);
  line-height: 1.2;
}

a,
.toggle-stats {
  color: green;
  text-decoration: none;
}

.gradient-background {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100vw;
  height: auto;
  z-index: -1;
  opacity: 0;
  transition: opacity 0.5s ease;
  pointer-events: none;
  mask: radial-gradient(
    ellipse at center,
    black 0%,
    black 25%,
    transparent 60%
  );
  -webkit-mask: radial-gradient(
    ellipse at center,
    black 0%,
    black 25%,
    transparent 60%
  );
}

.gradient-background.active { opacity: 0; }


h1 {
  color: #f0f6fc;
  text-align: center;
  margin-bottom: clamp(15px, 3vw, 25px);
  font-weight: 300;
  font-size: clamp(1.5rem, 3vw, 2.2rem);
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
}

h1.direction-step { display: none !important; }

h1.direction-step small {
  text-align: right;
  color: rgba(255, 255, 255, 0.5);
  text-transform: none;
  font-style: italic;
  font-size: clamp(0.9rem, 2vw, 1.1rem);
  display: block;
  margin-top: 0.5rem;
}

h1 small {
  font-size: 0.5em;
}

.upload-section {
  margin-bottom: clamp(15px, 3vw, 25px);
}

.upload-area {
  border: 2px dashed #30363d;
  border-radius: 8px;
  padding: clamp(15px, 3vw, 25px);
  text-align: center;
  margin-bottom: 15px;
  transition: all 0.3s ease;
  background: #0d1117;
  color: #e6edf3;
}

.upload-area:hover {
  border-color: #1f6feb;
  background: #161b22;
}

.upload-area.dragover {
  border-color: #1f6feb;
  background: #21262d;
}

.upload-options {
  display: flex;
  gap: clamp(10px, 2vw, 20px);
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
}

input[type="file"] {
  padding: 8px 12px;
  border: 1px solid #30363d;
  border-radius: 6px;
  background: #21262d;
  color: #e6edf3;
  font-size: 13px;
}

.lighting-controls {
  margin-top: 8px;
  padding: 10px;
  border: 1px solid #30363d;
  border-radius: 6px;
  background: #0d1117;
}

/* CSS-only lighting overlay using generated gradient masks */
.css-lighting { position: relative; }
.css-lighting::before, .css-lighting::after { content: ''; position: absolute; inset: 0; pointer-events: none; }
.css-lighting::before {
  /* Specular bands: transparent -> hard line -> fade to transparent, repeated */
  /* Primary and secondary phase-shifted layers for richness */
  background:
    repeating-linear-gradient(
      var(--light-angle, 35deg),
      transparent 0,
      transparent var(--band-gap, 120px),
      var(--highlight-color-soft, rgba(255,255,255,0.15)) var(--band-gap, 120px),
      var(--highlight-color, #ffffff) calc(var(--band-gap, 120px) + var(--soft-edge, 6px)),
      var(--highlight-color-0, rgba(255,255,255,0)) calc(var(--band-gap, 120px) + var(--soft-edge, 6px) + var(--band-width, 24px)),
      transparent calc(var(--band-gap, 120px) + var(--soft-edge, 6px) + var(--band-width, 24px) + var(--band-space, 120px))
    ),
    repeating-linear-gradient(
      calc(var(--light-angle, 35deg) + var(--band-phase, 8deg)),
      transparent 0,
      transparent var(--band-gap2, 90px),
      var(--highlight-color-soft, rgba(255,255,255,0.15)) var(--band-gap2, 90px),
      var(--highlight-color-weak, rgba(255,255,255,0.35)) calc(var(--band-gap2, 90px) + var(--soft-edge, 6px)),
      rgba(255,255,255,0) calc(var(--band-gap2, 90px) + var(--soft-edge, 6px) + var(--band-width2, 12px)),
      transparent calc(var(--band-gap2, 90px) + var(--soft-edge, 6px) + var(--band-width2, 12px) + var(--band-space2, 90px))
    ),
    /* Tertiary very subtle noise bands */
    repeating-linear-gradient(
      calc(var(--light-angle, 35deg) + var(--band-phase3, 17deg)),
      transparent 0,
      transparent var(--band-gap3, 140px),
      var(--highlight-color-soft, rgba(255,255,255,0.15)) var(--band-gap3, 140px),
      var(--highlight-color-weak2, rgba(255,255,255,0.2)) calc(var(--band-gap3, 140px) + var(--soft-edge, 6px)),
      rgba(255,255,255,0) calc(var(--band-gap3, 140px) + var(--soft-edge, 6px) + var(--band-width3, 10px)),
      transparent calc(var(--band-gap3, 140px) + var(--soft-edge, 6px) + var(--band-width3, 10px) + var(--band-space3, 140px))
    );
  /* Make lighting fixed to viewport so scroll changes interaction */
  background-attachment: fixed;
  /* Blend mode configurable via dropdown */
  mix-blend-mode: var(--blend-mode, normal);
  opacity: var(--highlight-alpha, 0.75);
  /* Use generated specularity mask (via Roughness). Accept full shorthand (image pos/size/repeat). */
  -webkit-mask: var(--lighting-mask, var(--spec-mask));
  mask: var(--lighting-mask, var(--spec-mask));
  mask-mode: luminance;
}
/* Never render a shadow layer */
.css-lighting::after { content: none !important; background: none !important; }

/* Do not render lighting until a roughness mask has been applied */
.css-lighting:not(.mask-ready):not(.show-mask)::before { content: none !important; }

/* Mask visualization mode: show the roughness-derived mask directly */
.css-lighting.show-mask::before {
  /* Remove masking and blending; paint the gradients directly */
  -webkit-mask: none !important;
  mask: none !important;
  mix-blend-mode: normal !important;
  opacity: 1 !important;
  /* Prefer exact pixel map (dataURL) if available; fallback to CSS gradient */
  background: var(--mask-visual, var(--spec-mask)) !important;
  /* Guard against later overlay CSS overriding shorthand from var() */
  background-size: 100% 100% !important;
  background-repeat: no-repeat !important;
  background-position: left top !important;
  background-attachment: scroll !important;
}
.css-lighting.show-mask::after { background: none !important; }

/* Lighting-only preview helpers */
#gradientPreview.lighting-only { background: none !important; background-color: #000 !important; }
.css-lighting.lighting-unmasked::before,
.css-lighting.lighting-unmasked::after {
  -webkit-mask: none !important;
  mask: none !important;
}
/* Unmasked-only preview should ignore blend mode and intensity */
.css-lighting.lighting-unmasked::before {
  mix-blend-mode: normal !important;
  opacity: 1 !important;
}
/* Masked-only preview: keep masking but ignore blend/intensity; draw on black */
.css-lighting.lighting-masked::before,
.css-lighting.lighting-masked::after {
  mix-blend-mode: normal !important;
  opacity: 1 !important;
}
/* Hide shadow layer entirely in masked-only mode */
.css-lighting.lighting-masked::after { content: none !important; background: none !important; }

.light-badges { position:absolute; top:6px; left:6px; z-index:3; display:flex; gap:6px; pointer-events:none; }
.light-badges .badge { background: rgba(0,0,0,0.5); color:#e6edf3; padding:2px 6px; border-radius:4px; font-size:12px; line-height:1.2; }

.url-input {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
}

#urlInput {
  padding: 8px 12px;
  border: 1px solid #30363d;
  border-radius: 6px;
  width: clamp(200px, 30vw, 300px);
  font-size: 13px;
  background: #21262d;
  color: #e6edf3;
}

button {
  background: #1f6feb;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.2s;
  box-shadow: 0 2px 6px rgba(31, 111, 235, 0.3), 0 1px 2px rgba(0, 0, 0, 0.2);
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

button:hover {
  background: #388bfd;
  box-shadow: 0 4px 12px rgba(31, 111, 235, 0.4), 0 2px 4px rgba(0, 0, 0, 0.3);
  transform: translateY(-1px);
}

button:disabled {
  background: #484f58;
  cursor: not-allowed;
}

.preview-section {
  /*margin: clamp(15px, 3vw, 25px) 0;*/
  display: none;
}

.stats {
  background: #21262d;
  padding: clamp(12px, 2.5vw, 18px);
  border-radius: 8px;
  margin: clamp(12px, 2.5vw, 18px) 0;
  border: 1px solid #30363d;
  border-left: 4px solid #1f6feb;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2), 0 1px 3px rgba(0, 0, 0, 0.1);
}

.stats-content {
  display: block;
}

.stats-detailed {
  display: none;
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #30363d;
}

.toggle-stats {
  margin-top: 8px;
  font-size: clamp(1rem, 2vw, 1.2rem);
  display: inline-block;
  cursor: pointer;
}


.original-section {
    display: flex;
    flex-direction: column;
    align-content: center;
    flex-wrap: wrap;
    align-items: center;
}

.original-section h3,
.preview-column h3 {
  margin: 0 0 10px 0;
  color: #e6edf3;
  font-weight: 500;
  font-size: clamp(1rem, 2vw, 1.2rem);
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
}

.preview-area .image-container {
    margin: 0 auto;
    max-width: 960px;
    width: 80%;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 40vh;
    flex-wrap: wrap;
    align-content: center;
    flex-direction: row;
}

.controls-sidebar .image-container { 
  border: 1px solid #243041; 
  border-radius: 8px; 
  overflow: hidden; 
  background: #0d1219; 
  transition: transform 0.2s, box-shadow 0.2s; 
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); 
  max-width: 300px;
  width: 100%;
}

.controls-sidebar .image-container img {
  width: 100%;
  height: auto;
  display: block;
}

.image-container.clickable {
  cursor: pointer;
}

.image-container.clickable:hover {
  transform: scale(1.02);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4), 0 4px 12px rgba(0, 0, 0, 0.2);
}

#originalImage {
  max-width: 100%;
  height: auto;
  display: block;
  width: 100%;
}

#gradientPreview {
  max-width: 100%;
  height: auto;
  display: block;
  width: 100%;
  min-height: 300px; /* fallback so preview area is visible before CSS arrives */
}

.options-grid { display: flex; flex-direction: column; gap: clamp(12px, 2.5vw, 18px); margin: 0; padding: 0; background: transparent; border-radius: 0; }
.preview-section { display: block; }

.option-column {
  display: flex;
  flex-direction: column;
  gap: clamp(12px, 2.5vw, 18px);
}

.option-group {
  background: #21262d;
  padding: clamp(12px, 2.5vw, 18px);
  border-radius: 8px;
  border: 1px solid #30363d;
  border-left: 4px solid #1f6feb;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2),
    inset 0 1px 1px rgba(255, 255, 255, 0.03);
    margin-bottom: 1.5em;
}

.option-group label {
  display: block;
  margin-bottom: 6px;
  font-weight: 600;
  color: #e6edf3;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  font-size: 13px;
}

.option-group input[type="range"] {
  width: 100%;
  margin-bottom: 6px;
}

.option-group input[type="text"],
.option-group select {
  width: calc(100% - 16px);
  padding: 8px;
  border: 1px solid #30363d;
  border-radius: 6px;
  margin-bottom: 6px;
  background: #0d1117;
  color: #e6edf3;
  font-size: 13px;
}

.option-group select {
  width: 100%;
}

.help-text {
  font-size: 11px;
  color: #8b949e;
  line-height: 1.3;
}

.checkbox-option {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 10px;
}

.checkbox-option input[type="checkbox"] {
  margin: 0;
}

.optimal-hint {
  font-size: 12px;
  color: #3fb950;
  font-weight: normal;
  margin-left: 8px;
}

.css-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.css-header h3 {
  margin: 0;
  color: #e6edf3;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
}

.switch-container {
  display: flex;
  align-items: center;
  gap: 8px;
}

.switch {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 24px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #484f58;
  transition: 0.4s;
  border-radius: 24px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: 0.4s;
  border-radius: 50%;
}

input:checked + .slider {
  background-color: #1f6feb;
}

input:checked + .slider:before {
  transform: translateX(26px);
}

.switch-label {
  font-size: 14px;
  color: #e6edf3;
  font-weight: 500;
}

.spinner-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.spinner {
  width: 50px;
  height: 50px;
  border: 4px solid #30363d;
  border-top: 4px solid #1f6feb;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

.css-output {
  margin-top: clamp(15px, 3vw, 25px);
  max-width: 85%;
  margin-left: auto;
  margin-right: auto;
}

.css-code-container {
  position: relative;
}

.css-code {
  background: #0d1117;
  border: 1px solid #30363d;
  border-radius: 8px;
  padding: clamp(12px, 2.5vw, 18px);
  white-space: pre-wrap;
  word-wrap: break-word;
  font-family: "JetBrains Mono", "Fira Code", "Courier New", monospace;
  font-size: clamp(11px, 1.5vw, 13px);
  max-height: 100vh;
  overflow-y: auto;
  line-height: 1.4;
  color: #e6edf3;
  transition: all 0.2s ease;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 1px 3px rgba(0, 0, 0, 0.2);
}

.css-code:hover {
  background: #21262d;
}

.copy-button {
  position: absolute;
  top: 12px;
  right: 30px;
  background: #1f6feb;
  color: white;
  border: none;
  width: 36px;
  height: 36px;
  border-radius: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  transition: all 0.2s ease;
  z-index: 10;
  opacity: 0;
  pointer-events: none;
}

.css-code-container:hover .copy-button {
  opacity: 1;
  pointer-events: auto;
}

.copy-button:hover {
  background: #388bfd;
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

.copy-button:active {
  transform: scale(0.95);
}

.copy-button.copied {
  background: #3fb950;
}

.copy-icon {
  display: block;
  pointer-events: none;
  color: white;
  font-size: 18px;
  line-height: 1;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui,
    sans-serif;
}

.optimization-result {
  margin: 20px 0;
  padding: 15px;
  background: #0c3328;
  border-radius: 8px;
  font-size: 14px;
  border-left: 4px solid #3fb950;
  color: #e6edf3;
}

/* Lightbox Modal */
.lightbox {
  display: none;
  position: fixed;
  z-index: 2000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.8);
  justify-content: center;
  align-items: center;
}

.lightbox-content {
  max-width: 90%;
  max-height: 90%;
  position: relative;
}

.lightbox img,
.lightbox div {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

.lightbox-close {
  position: absolute;
  top: -40px;
  right: 0;
  color: white;
  font-size: 30px;
  cursor: pointer;
  background: none;
  border: none;
  padding: 0;
}

.resizable-preview {
  position: relative;
  resize: both;
  overflow: hidden;
  min-width: 200px;
  min-height: 150px;
}

.resize-handle {
  position: absolute;
  background: rgba(225, 237, 243, 0.8);
  border: 1px solid #30363d;
}

.resize-handle.corner {
  width: 12px;
  height: 12px;
  border-radius: 2px;
}

.resize-handle.bottom-right {
  bottom: 0;
  right: 0;
  cursor: nw-resize;
}

.resize-handle.bottom-left {
  bottom: 0;
  left: 0;
  cursor: ne-resize;
}

.resize-handle.top-right {
  top: 0;
  right: 0;
  cursor: ne-resize;
}

.resize-handle.top-left {
  top: 0;
  left: 0;
  cursor: nw-resize;
}

@media (max-width: 768px) {
  body {
   /* padding: 10px;*/
    font-size: 13px;
  }
  

  .upload-options {
    flex-direction: column;
    gap: 12px;
  }

  #urlInput {
    width: 100%;
    min-width: 250px;
  }

  .options-grid {
    grid-template-columns: 1fr;
    padding: 12px;
    gap: 12px;
  }
  
  .option-group {
    padding: 12px;
  }

  h1.direction-step {
    margin-top: 2rem;
    font-size: 1.5rem;
  }
  
  h1.direction-step small {
    font-size: 0.9rem;
  }
}

@media (max-width: 480px) {
  body {
    padding: 8px;
  }
  
  .upload-area {
    padding: 15px;
  }
  
  .css-code {
    padding: 12px;
    font-size: 11px;
  }
  
  .main-header {
    font-size: 2rem;
  }
}

/* Hide map CSS code blocks but keep functionality for downloads */
.map-css-section {
  display: none !important;
}

    </style>
</head>
<body>
  <div class="app-layout">
    <header class="fixed-header">
      <div class="header-title">
        <h1>img2css</h1>
        <p>Convert any image to a single CSS gradient. <a href="https://github.com/digitalisstudios/img2css" target="_blank">Docs</a></p>
      </div>
      <div class="header-stats">
        <div class="stat-line" id="headerStats"></div>
      </div>
    </header>

    <div class="main-content">
      <div class="preview-area">
        <div class="upload-section stats" style="max-width: 960px; margin: 1em auto;">
          
          <div class="upload-area" id="uploadArea">
            <p>Drag and drop an image here or choose an option below</p>
          </div>
          <div class="upload-options" >
            <div>
              <input type="file" id="imageInput" accept="image/*">
            </div>
            <div class="url-input">
              <input type="text" id="urlInput" placeholder="Or enter image URL" value="https://i.imgur.com/Qc3TD8h.jpeg">
              <button id="loadUrlBtn">Load URL</button>
            </div>
          </div>
        </div>

        <div class="preview-section" id="previewSection">
        	<div id="stats" class="stats" style="max-width: 960px; margin: 1em auto;">
	          <div class="stats-content" id="statsContent"></div>
	          <div class="stats-detailed" id="statsDetailed"></div>
	          <span class="toggle-stats" id="toggleStats">Show detailed stats</span>
	        </div>
          
          <div class="image-container">
          	<h2 style="margin-bottom: 5px;">Pure CSS Preview</h2>
            <div id="gradientPreview"></div>
          </div>


          <div class="css-output" id="cssOutput" style="display: none;">
            <h3>Generated CSS</h3>
            <div class="css-header">
              <div class="switch-container">
                <span class="switch-label">Minify</span>
                <label class="switch">
                  <input type="checkbox" id="minifiedCheckbox">
                  <span class="slider"></span>
                </label>
              </div>
            </div>
            <div class="css-code-container">
              <div class="css-code" id="cssCode"></div>
              <button id="copyBtn" class="copy-button" title="Copy CSS">
                <span class="copy-icon">‚éò</span>
              </button>
            </div>

            <div class="map-css-section">
              <h3 style="margin-top:16px;">Specularity CSS (via Roughness)</h3>
              <div class="css-code-container">
                <div class="css-code" id="specCssCode"></div>
                <button id="specDownloadBtn" class="copy-button" title="Download Specular CSS">
                  <span class="copy-icon">‚§ì</span>
                </button>
              </div>
            </div>

            <div class="map-css-section">
              <h3 style="margin-top:16px;">Map CSS (Normal)</h3>
              <div class="css-code-container">
                <div class="css-code" id="normalCssCode"></div>
                <button id="normalDownloadBtn" class="copy-button" title="Download Normal CSS">
                  <span class="copy-icon">‚§ì</span>
                </button>
              </div>
            </div>

            <div class="map-css-section">
              <h3 style="margin-top:16px;">Map CSS (Roughness)</h3>
              <div class="css-code-container">
                <div class="css-code" id="roughCssCode"></div>
                <button id="roughDownloadBtn" class="copy-button" title="Download Roughness CSS">
                  <span class="copy-icon">‚§ì</span>
                </button>
              </div>
            </div>

            <div class="map-css-section">
              <h3 style="margin-top:16px;">Map CSS (Subject Normal)</h3>
              <div class="css-code-container">
                <div class="css-code" id="subjectnormalCssCode"></div>
                <button id="subjectnormalDownloadBtn" class="copy-button" title="Download Subject Normal CSS">
                  <span class="copy-icon">‚§ì</span>
                </button>
              </div>
            </div>

            <div class="map-css-section">
              <h3 style="margin-top:16px;">Reflection CSS (via Subject Normal)</h3>
              <div class="css-code-container">
                <div class="css-code" id="reflFromSubjectnormalCssCode"></div>
                <button id="reflFromSubjectnormalDownloadBtn" class="copy-button" title="Download Reflection (via Subject Normal) CSS">
                  <span class="copy-icon">‚§ì</span>
                </button>
              </div>
            </div>

            <div style="margin-top:12px; text-align:right;">
              <button id="downloadAllBtn" title="Download all generated maps">Download All Maps</button>
            </div>
          </div>
        </div>
      </div>

      <div class="controls-sidebar">
        <div class="original-section">
          <h3>Original (Source image)</h3>
          <div class="image-container">
            <img id="originalImage" alt="Original">
          </div>
        </div>

        

        <div class="control-tabs">
          <button class="control-tab active" id="mainControlsTab">
            <span class="control-tab-icon">‚öôÔ∏è</span>
            <span>Settings</span>
          </button>
          <button class="control-tab" id="pluginsTab">
            <span class="control-tab-icon">üîå</span>
            <span>Plugins</span>
          </button>
        </div>

        <div class="control-panel active" id="mainControlsPanel">
          <div class="options-grid">
            <div class="option-column">
              <div class="option-group">
                <label for="processingModeSelect">Processing Mode</label>
                <select id="processingModeSelect">
                  <option value="auto">Auto (detect orientation)</option>
                  <option value="rows">Rows (horizontal gradients)</option>
                  <option value="columns" selected>Columns (vertical gradients)</option>
                  <option value="hybrid">Hybrid (blend both directions)</option>
                </select>
                <div class="help-text">
                  Choose gradient direction manually
                </div>
              </div>

              <div class="option-group">
                <label for="maxSizeInput">Max CSS file size</label>
                <input type="text" id="maxSizeInput" placeholder="e.g., 500KB, 2MB">
              </div>
            </div>

            <div class="option-column">
              <div class="option-group">
                <label for="detailsSlider">
                  Details: <span id="detailsValue">70</span>%<span id="optimalDetails" class="optimal-hint" style="display: none;"></span>
                </label>
                <input type="range" id="detailsSlider" min="1" max="100" value="70">
                <div class="help-text">
                  Higher values preserve more detail
                </div>
              </div>
            </div>

            <div class="option-column">
              <div class="option-group">
                <label for="compressionSlider">
                  Compression: <span id="compressionValue">0</span>%<span id="optimalCompression" class="optimal-hint" style="display: none;"></span>
                </label>
                <input type="range" id="compressionSlider" min="0" max="100" value="-">
                <div class="help-text">
                  Higher values reduce file size
                </div>
              </div>
            </div>

            <!-- Hidden posterization option -->
            <div class="option-group" style="display: none;">
              <label for="posterizationStrengthSlider">Posterization: <span id="posterizationStrengthValue">0%</span></label>
              <input type="range" id="posterizationStrengthSlider" min="0" max="100" value="0" step="5">
              <div class="help-text">
                Limit gradients to colors from original image (0% = off, 100% = full posterization)
              </div>
            </div>
          </div>
        </div>

        <div class="control-panel" id="pluginsPanel">
          
            <div id="pluginControlsMount"></div>
        </div>
      </div>
    </div>

    <div class="spinner-overlay" id="spinnerOverlay">
      <div class="spinner"></div>
    </div>
  </div>

    <script src="plugin-ui.js"></script>
    <script src="img2css.js"></script>
    <script>
        class img2cssUI {
        	firstLoad = true;


            constructor(config = {}) {
            	console.log("Initializing img2cssUI with config:", config);
                // Create instance of the core converter
                this.core = new img2css(config);
                
                // Auto-generation timeout
                this.generationTimeout = null;
                
                // Setup UI if DOM elements exist
                if (typeof document !== 'undefined' && document.getElementById('uploadArea')) {
                    this.setupEventListeners();
                }
                
                // If source is provided, load it automatically
                if (this.core.config.source) {
                    this.loadFromSource(this.core.config.source);
                }
            }

            initPluginUI(pluginMount) {
                if (!pluginMount) return;
                if (!window.PluginUI) {
                    console.warn('[Plugins] plugin-ui.js not loaded.');
                    pluginMount.innerHTML = '<div class="help-text">No plugins UI available (plugin-ui.js not loaded).</div>';
                    return;
                }
                
                const self = this;
                
                // Auto-load and initialize plugins
                window.PluginUI.autoInit(
                    pluginMount,
                    function(id, values) {
                        // Handle lighting changes - only update CSS variables, don't regenerate
                        if (id === 'lighting') {
                            self.applyLightingVars(values, true); // true = isUserChange
                            return; // Don't schedule full regeneration for lighting changes
                        }
                        
                        // Handle MapExtractor preview visibility
                        if (id === 'mapExtractor') {
                            self.updateMapPreviewVisibility(values);
                        }
                        
                        self.scheduleGeneration();
                    },
                    {
                        mapExtractor: {
                            onMapCSS: function(data) {
                                var type = data.type;
                                var css = data.css;
                                var fromImage = data.fromImage;
                                
                                // Route CSS based previews for normal, roughness, and subject normal maps
                                if (type === 'normal') {
                                    self.updateNormalGradientClass(css);
                                    var normalEl = document.getElementById('normalGradientPreview');
                                    if (normalEl) normalEl.className = 'normal-gradient-preview';
                                    var outN = document.getElementById('normalCssCode'); 
                                    if (outN) outN.textContent = css;
                                } else if (type === 'roughness') {
                                    self.updateRoughnessGradientClass(css);
                                    var roughnessEl = document.getElementById('roughnessGradientPreview');
                                    if (roughnessEl) roughnessEl.className = 'roughness-gradient-preview';
                                    var outR = document.getElementById('roughCssCode'); 
                                    if (outR) outR.textContent = css;
                                    // Also use roughness as specularity CSS
                                    var outSpec = document.getElementById('specCssCode'); 
                                    if (outSpec) outSpec.textContent = css;
                                    
                                    // Update CSS-lighting mask only when CSS came from the pixel map conversion
                                    if (fromImage) {
                                        var bg = self.extractBackgroundFromCSS(css);
                                        var gp = document.getElementById('gradientPreview');
                                        if (bg && gp) {
                                            // Emit beforeMaskLoaded hook for lighting plugin
                                            try {
                                                if (self.pluginUI && self.pluginUI.getValues) {
                                                    var st = self.pluginUI.getValues();
                                                    if (st && st.lighting) {
                                                        self.emitLightingHook('beforeMaskLoaded', { 
                                                            mask: bg, 
                                                            element: gp, 
                                                            mapType: 'roughness',
                                                            lightingState: st.lighting 
                                                        });
                                                    }
                                                }
                                            } catch(_) {}
                                            
                                            gp.style.setProperty('--spec-mask', bg);
                                            gp.classList.add('mask-ready');
                                            
                                            // Emit onMaskLoaded hook for lighting plugin
                                            try {
                                                if (self.pluginUI && self.pluginUI.getValues) {
                                                    var st = self.pluginUI.getValues();
                                                    if (st && st.lighting) {
                                                        self.emitLightingHook('onMaskLoaded', { 
                                                            mask: bg, 
                                                            element: gp, 
                                                            mapType: 'roughness',
                                                            lightingState: st.lighting 
                                                        });
                                                    }
                                                }
                                            } catch(_) {}
                                            
                                            // Apply clearcoat lighting preset values now that roughness map is ready
                                            try {
                                                if (self.pluginUI && self.pluginUI.getValues) {
                                                    var st = self.pluginUI.getValues();
                                                    if (st && st.lighting && (st.lighting.preset === 'clearcoat' || !st.lighting.preset)) {
                                                        var clearcoatValues = {
                                                            preset: 'clearcoat',
                                                            lightAngle: 171,
                                                            highlightAlpha: 1.0,
                                                            blendMode: 'screen',
                                                            color: '#ffffff',
                                                            bandGap: 110,
                                                            bandWidth: 50,
                                                            softEdge: 4,
                                                            bandPhase: 2,
                                                            bandGap2: 80,
                                                            bandWidth2: 10,
                                                            bandPhase3: 14,
                                                            bandGap3: 120,
                                                            bandWidth3: 8
                                                        };
                                                        Object.assign(st.lighting, clearcoatValues);
                                                        self.applyLightingVars(st.lighting, false); // false = not user change, automatic preset application
                                                    }
                                                }
                                            } catch(_) {}
                                        }
                                    }
                                } else if (type === 'subjectnormal') {
                                    self.updateSubjectNormalGradientClass(css);
                                    var subjectnormalEl = document.getElementById('subjectnormalGradientPreview');
                                    if (subjectnormalEl) subjectnormalEl.className = 'subjectnormal-gradient-preview';
                                    var outS = document.getElementById('subjectnormalCssCode'); 
                                    if (outS) outS.textContent = css;
                                    var outReflS = document.getElementById('reflFromSubjectnormalCssCode'); 
                                    if (outReflS) outReflS.textContent = css;
                                    
                                    // Optionally use subject normal as an alternative highlight mask
                                    var bg = self.extractBackgroundFromCSS(css);
                                    var gp = document.getElementById('gradientPreview');
                                    if (bg && gp) {
                                        gp.style.setProperty('--refl-mask', bg);
                                    }
                                }
                            },
                            onMap: function(data) {
                                var type = data.type;
                                var dataURL = data.dataURL;
                                
                                self.lastMapData = self.lastMapData || {};
                                self.lastMapData[type] = dataURL || null;
                                
                                // Only handle image-based previews for maps that don't use CSS gradients
                                var mapToImg = { albedo: 'albedoImage', irradiance: 'irradianceImage', depth: 'depthImage', object: 'objectImage' };
                                var imgId = mapToImg[type];
                                if (imgId) {
                                    var img = document.getElementById(imgId);
                                    if (img && dataURL) {
                                        img.src = dataURL;
                                    }
                                }
                                
                                // Roughness: prefer exact base64 image for masking and visualization
                                if (type === 'roughness' && dataURL) {
                                    var gp = document.getElementById('gradientPreview');
                                    if (gp) {
                                        var urlDecl = 'url("' + dataURL + '") left top / 100% 100% no-repeat';
                                        gp.style.setProperty('--spec-mask', urlDecl);
                                        gp.classList.add('mask-ready');
                                        gp.style.setProperty('--mask-visual', urlDecl);
                                    }
                                }
                            }
                        }
                    },
                    {
                        basePath: 'plugins/',
                        pluginFiles: [
                            'soft-posterize.global.js',
                            'map-extractor.global.js',
                            'lighting.global.js'
                        ]
                    }
                );
                
                // Store reference to pluginUI when it's created
                setTimeout(() => {
                    this.pluginUI = pluginMount.pluginUIInstance;
                    // Add collapsible functionality to plugins
                    this.setupPluginCollapse();
                    // Initialize map preview visibility
                    if (this.pluginUI && this.pluginUI.state && this.pluginUI.state.mapExtractor) {
                        this.updateMapPreviewVisibility(this.pluginUI.state.mapExtractor);
                    }
                }, 100);
            }

            emitLightingHook(eventName, payload) {
                // Emit hooks specifically to the lighting plugin
                try {
                    // Get the current plugin instances
                    const instances = this.pluginUI ? this.pluginUI.build() : [];
                    // Find the lighting plugin instance
                    const lightingInstance = instances.find(inst => inst && inst.hooks && (inst.hooks.beforeMaskLoaded || inst.hooks.onMaskLoaded));
                    if (lightingInstance && lightingInstance.hooks && lightingInstance.hooks[eventName]) {
                        const hookFn = lightingInstance.hooks[eventName];
                        if (typeof hookFn === 'function') {
                            return hookFn(payload);
                        }
                    }
                } catch (e) {
                    console.warn('Error emitting lighting hook:', eventName, e);
                }
                return payload;
            }

            setupPluginCollapse() {
                // Wrap each plugin in a collapsible container
                const pluginMount = document.getElementById('pluginControlsMount');
                if (!pluginMount) return;
                
                const pluginSections = pluginMount.querySelectorAll('.plugin-section, .option-group');
                pluginSections.forEach(section => {
                    if (section.querySelector('.plugin-container')) return; // Already wrapped
                    
                    const title = section.querySelector('h3, h4, label')?.textContent || 'Plugin';
                    const switchElement = section.querySelector('.switch');
                    const toggleInput = section.querySelector('.switch input');
                    
                    if (!switchElement || !toggleInput) return; // Skip if no toggle switch found
                    
                    // Create wrapper structure
                    const wrapper = document.createElement('div');
                    wrapper.className = 'plugin-container collapsed';
                    
                    const header = document.createElement('div');
                    header.className = 'plugin-header';
                    
                    const titleEl = document.createElement('h4');
                    titleEl.className = 'plugin-title';
                    titleEl.textContent = title;
                    
                    const toggleContainer = document.createElement('div');
                    toggleContainer.className = 'plugin-toggle-container';
                    
                    // Clone the entire switch element to maintain styling
                    const switchClone = switchElement.cloneNode(true);
                    
                    const collapseIcon = document.createElement('span');
                    collapseIcon.className = 'plugin-collapse-icon';
                    collapseIcon.textContent = '‚ñº';
                    
                    toggleContainer.appendChild(switchClone);
                    toggleContainer.appendChild(collapseIcon);
                    
                    header.appendChild(titleEl);
                    header.appendChild(toggleContainer);
                    
                    const content = document.createElement('div');
                    content.className = 'plugin-content';
                    
                    // Move all content to content area, excluding title and enable switch
                    const elementsToMove = Array.from(section.children);
                    elementsToMove.forEach(child => {
                        // Skip title elements (h3, h4, labels that contain the plugin name)
                        const isTitle = (child.tagName === 'H3' || child.tagName === 'H4' || 
                                       (child.tagName === 'LABEL' && child.textContent.includes(title)));
                        
                        // Skip the switch element and any enable/disable switches
                        const isSwitch = (child === switchElement || child.contains(switchElement) ||
                                        child.classList?.contains('switch') ||
                                        (child.tagName === 'LABEL' && child.textContent.toLowerCase().includes('enable')));
                        
                        if (!isTitle && !isSwitch) {
                            content.appendChild(child);
                        }
                    });
                    
                    // Clean up any remaining title or switch elements
                    const remainingTitles = section.querySelectorAll('h3, h4');
                    const remainingSwitches = section.querySelectorAll('.switch');
                    const remainingEnableLabels = section.querySelectorAll('label');
                    
                    remainingTitles.forEach(el => el.remove());
                    remainingSwitches.forEach(el => el.remove());
                    remainingEnableLabels.forEach(el => {
                        if (el.textContent.toLowerCase().includes('enable')) {
                            el.remove();
                        }
                    });
                    
                    wrapper.appendChild(header);
                    wrapper.appendChild(content);
                    
                    section.parentNode.replaceChild(wrapper, section);
                    
                    // Add click handler for collapse/expand (excluding the switch area)
                    header.addEventListener('click', (e) => {
                        if (e.target.closest('.switch') || e.target.closest('.plugin-toggle-container')) {
                            return; // Don't collapse when clicking on the switch or toggle area
                        }
                        wrapper.classList.toggle('collapsed');
                    });
                    
                    // Ensure the cloned switch maintains functionality
                    const clonedInput = switchClone.querySelector('input');
                    const originalInput = toggleInput;
                    if (clonedInput && originalInput) {
                        clonedInput.addEventListener('change', () => {
                            originalInput.checked = clonedInput.checked;
                            originalInput.dispatchEvent(new Event('change', { bubbles: true }));
                        });
                    }
                });
            }

            // Delegate to core for CSS generation
            async generateCSS(imageSource, options = {}) {
                // Update core config with options first
                Object.assign(this.core.config, options);
                this.core.config.source = imageSource;
                
                // Generate CSS and return full result object for UI compatibility
                const css = await this.core.toCSS();
                return this.core.stats; // Return the detailed stats the UI expects
            }

            // Get imageData property from core
            get imageData() {
                return this.core.imageData;
            }

            // Delegate utility methods to core
            formatFileSize(sizeKB) {
                return this.core.formatFileSize(sizeKB);
            }

            parseMaxSizeToKB(maxSizeStr) {
                return this.core.parseMaxSizeToKB(maxSizeStr);
            }

            estimateCSSSize(width, height, details, compression) {
                return this.core.estimateCSSSize(width, height, details, compression);
            }

            calculateImageComplexity(data, width, height) {
                return this.core.calculateImageComplexity(data, width, height);
            }

            /*
            async findOptimalSettingsForImage(preserveParameter = null) {
                return await this.core.core.findOptimalSettingsForImage(preserveParameter);
            }
            */

            // === UI-Related Methods (only work when DOM is available) ===

            setupEventListeners() {
                const elements = {
                    uploadArea: document.getElementById('uploadArea'),
                    imageInput: document.getElementById('imageInput'),
                    urlInput: document.getElementById('urlInput'),
                    loadUrlBtn: document.getElementById('loadUrlBtn'),
                    copyBtn: document.getElementById('copyBtn'),
                    detailsSlider: document.getElementById('detailsSlider'),
                    detailsValue: document.getElementById('detailsValue'),
                    compressionSlider: document.getElementById('compressionSlider'),
                    compressionValue: document.getElementById('compressionValue'),
                    maxSizeInput: document.getElementById('maxSizeInput'),
                    minifiedCheckbox: document.getElementById('minifiedCheckbox'),
                    processingModeSelect: document.getElementById('processingModeSelect'),
                    originalPaletteCheckbox: document.getElementById('originalPaletteCheckbox'),
                    toggleStats: document.getElementById('toggleStats')
                };

                let firstLoad = true;

                
                elements.uploadArea.addEventListener('click', (e) => {
                    if (e.target !== elements.imageInput) {
                        elements.imageInput.click();
                    }
                });
                elements.uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
                elements.uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                elements.uploadArea.addEventListener('drop', (e) => this.handleDrop(e));
                
                elements.imageInput.addEventListener('change', (e) => this.handleFileSelect(e));
                elements.loadUrlBtn.addEventListener('click', () => this.loadFromUrl());
                elements.copyBtn.addEventListener('click', () => this.copyCSS());
                // Show mask toggle
                                const specDl = document.getElementById('specDownloadBtn');
                if (specDl) specDl.addEventListener('click', () => this.downloadMapCSS('specular'));
                const normalDl = document.getElementById('normalDownloadBtn');
                if (normalDl) normalDl.addEventListener('click', () => this.downloadMapCSS('normal'));
                const roughDl = document.getElementById('roughDownloadBtn');
                if (roughDl) roughDl.addEventListener('click', () => this.downloadMapCSS('roughness'));
                const subjNormDl = document.getElementById('subjectnormalDownloadBtn');
                if (subjNormDl) subjNormDl.addEventListener('click', () => this.downloadMapCSS('subjectnormal'));
                const reflFromSubjDl = document.getElementById('reflFromSubjectnormalDownloadBtn');
                if (reflFromSubjDl) reflFromSubjDl.addEventListener('click', () => this.downloadMapCSS('reflViaSubjectnormal'));
                const allBtn = document.getElementById('downloadAllBtn');
                if (allBtn) allBtn.addEventListener('click', () => this.downloadAllMaps());
                elements.toggleStats.addEventListener('click', () => this.toggleDetailedStats());
                
                elements.detailsSlider.addEventListener('input', (e) => {
                    elements.detailsValue.textContent = e.target.value;
                    this.updateStats();
                    this.scheduleGeneration();
                    
                    setTimeout(async () => {
                        if (await this.autoAdjustForMaxSize('details')) {
                            this.updateStats();
                        }
                    }, 100);
                });
                
                elements.compressionSlider.addEventListener('input', (e) => {
                    elements.compressionValue.textContent = e.target.value;
                    this.updateStats();
                    this.scheduleGeneration();
                    
                    setTimeout(async () => {
                        if (await this.autoAdjustForMaxSize('compression')) {
                            this.updateStats();
                        }
                    }, 100);
                });
                
                elements.maxSizeInput.addEventListener('input', () => {
                    this.updateStats();
                    this.scheduleGeneration();
                    
                    if (this.imageData && elements.maxSizeInput.value.trim()) {
                        setTimeout(() => this.core.findOptimalSettings(), 500);
                    }
                });
                
                elements.minifiedCheckbox.addEventListener('change', () => {
                    this.updateStats();
                    this.scheduleGeneration();
                });
                
                elements.processingModeSelect.addEventListener('change', () => {
                    this.updateStats();
                    this.scheduleGeneration();
                });
                
                
                const posterizationStrengthSlider = document.getElementById('posterizationStrengthSlider');
                const posterizationStrengthValue = document.getElementById('posterizationStrengthValue');
                
                posterizationStrengthSlider.addEventListener('input', () => {
                    posterizationStrengthValue.textContent = posterizationStrengthSlider.value + '%';
                    this.updateStats();
                    this.scheduleGeneration();
                });
                
                // Set initial values from config
                if (this.core.config.processing.details !== 100) {
                    elements.detailsSlider.value = this.core.config.processing.details;
                    elements.detailsValue.textContent = this.core.config.processing.details;
                }
                
                if (this.core.config.processing.compression !== 15) {
                    elements.compressionSlider.value = this.core.config.processing.compression;
                    elements.compressionValue.textContent = this.core.config.processing.compression;
                }
                
                if (this.core.config.maxSize) {
                    elements.maxSizeInput.value = this.core.config.maxSize;
                }

                // Auto-render plugin controls if available
                const pluginMount = document.getElementById('pluginControlsMount') || (function(){
                  const grids = document.getElementsByClassName('options-grid');
                  if (grids.length) {
                    const mountWrap = document.createElement('div');
                    mountWrap.className = 'option-column';
                    const hdr = document.createElement('h3'); hdr.textContent = 'Plugins'; hdr.style.margin = '0 0 10px';
                    mountWrap.appendChild(hdr);
                    const mount = document.createElement('div'); mount.id = 'pluginControlsMount';
                    mountWrap.appendChild(mount);
                    grids[0].appendChild(mountWrap);
                    return mount;
                  }
                  return null;
                })();
                this.initPluginUI(pluginMount);

                // Layout is now handled in HTML structure
                
                // Setup tab functionality
                const mainControlsTab = document.getElementById('mainControlsTab');
                const pluginsTab = document.getElementById('pluginsTab');
                const mainControlsPanel = document.getElementById('mainControlsPanel');
                const pluginsPanel = document.getElementById('pluginsPanel');
                
                mainControlsTab.addEventListener('click', () => {
                    mainControlsTab.classList.add('active');
                    pluginsTab.classList.remove('active');
                    mainControlsPanel.classList.add('active');
                    pluginsPanel.classList.remove('active');
                });
                
                pluginsTab.addEventListener('click', () => {
                    pluginsTab.classList.add('active');
                    mainControlsTab.classList.remove('active');
                    pluginsPanel.classList.add('active');
                    mainControlsPanel.classList.remove('active');
                });
            }

            scheduleGeneration() {
                // Clear existing timeout
                if (this.generationTimeout) {
                    clearTimeout(this.generationTimeout);
                }
                
                // Schedule new generation with 1 second delay
                this.generationTimeout = setTimeout(() => {
                    if (this.imageData) {
                        this.generateGradient();
                        if (this.firstLoad) {
							//this.firstLoad = false;
							var that = this;;
							this.findOptimalSettings().then(() => {
								that.firstLoad = false;
							});
						}

                    }
                }, 1000);
            }

            showSpinner() {
                document.getElementById('spinnerOverlay').style.display = 'flex';
            }

            hideSpinner() {
                document.getElementById('spinnerOverlay').style.display = 'none';
            }

            toggleDetailedStats() {
                const detailed = document.getElementById('statsDetailed');
                const toggle = document.getElementById('toggleStats');
                
                if (detailed.style.display === 'none' || !detailed.style.display) {
                    detailed.style.display = 'block';
                    toggle.textContent = 'Hide detailed stats';
                } else {
                    detailed.style.display = 'none';
                    toggle.textContent = 'Show detailed stats';
                }
            }

            loadFromUrl() {
                const url = document.getElementById('urlInput').value.trim();
                if (!url) return;
                
                this.showSpinner();
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    this.hideSpinner();
                    this.processImage(img);
                    this.showPreview(url);
                    this.applyAutoOptimizationIfNeeded();
                };
                img.onerror = () => {
                    this.hideSpinner();
                    alert('Failed to load image from URL. Please check the URL and try again.');
                };
                img.src = url;
            }

            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.add('dragover');
            }
            
            handleDragLeave(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
            }
            
            handleDrop(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.loadImage(files[0]);
                }
            }
            
            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.loadImage(file);
                }
            }
            
            loadImage(file) {
                if (!file.type.startsWith('image/')) {
                    alert('Please select a valid image file.');
                    return;
                }
                
                this.showSpinner();
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.hideSpinner();
                        this.processImage(img);
                        this.showPreview(e.target.result);
                        this.applyAutoOptimizationIfNeeded();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            loadFromSource(source) {
                if (typeof source === 'string') {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        this.processImage(img);
                        this.showPreview(source);
                        this.applyAutoOptimizationIfNeeded();
                    };
                    img.onerror = () => {
                        console.error('Failed to load image from URL:', source);
                    };
                    img.src = source;
                } else if (source instanceof File) {
                    this.loadImage(source);
                } else {
                    console.error('Invalid source provided. Must be URL string or File object.');
                }
            }
            
            applyAutoOptimizationIfNeeded() {
                // Only run auto-optimization if not skipped in config
                if (this.core.config.autoOptimize == true) {
                    this.findOptimalSettings();
                }
                // Always trigger initial CSS generation
                this.scheduleGeneration();
            }
            
            showPreview(imageSrc) {
                document.getElementById('previewSection').style.display = 'block';
                document.getElementById('originalImage').src = imageSrc;
            }
            
            processImage(img) {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                
                ctx.drawImage(img, 0, 0);
                const rawImageData = ctx.getImageData(0, 0, img.width, img.height);
                
                this.core.imageData = {
                    width: img.width,
                    height: img.height,
                    data: rawImageData.data
                };
                
                this.core.canvas = canvas;
                this.core.ctx = ctx;
                
                this.showStats(img.width, img.height);
                this.updateStats();
                // Derive a default lighting color from dominant non-black/white tones
                this.applyDominantLightingColor();
                
                // Force update MapExtractor custom content with new image
                if (this.pluginUI && this.pluginUI.forceUpdateCustomContent) {
                    this.pluginUI.forceUpdateCustomContent('mapExtractor');
                }
            }

            applyDominantLightingColor() {
                try {
                    const id = this.core.imageData;
                    if (!id || !id.data) return;
                    // Sample pixels with stride for performance
                    const { data, width, height } = id;
                    const total = width * height;
                    const stride = Math.max(4, Math.floor((total / 50000)) * 4); // aim ~50k samples
                    const bins = new Map();
                    // quantization step
                    const q = 32; // 8 levels per channel
                    for (let i = 0; i < data.length; i += stride) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        const maxc = Math.max(r, g, b), minc = Math.min(r, g, b);
                        const lum = (r + g + b) / 3;
                        // skip near black/white
                        if (lum < 18 || lum > 235) continue;
                        // skip near grey extremes (very low saturation)
                        if (maxc - minc < 12) continue;
                        const rq = Math.floor(r / q) * q;
                        const gq = Math.floor(g / q) * q;
                        const bq = Math.floor(b / q) * q;
                        const key = rq + ',' + gq + ',' + bq;
                        bins.set(key, (bins.get(key) || 0) + 1);
                    }
                    if (!bins.size) return;
                    // choose dominant bin
                    let bestKey = null, bestCount = -1;
                    for (const [k, c] of bins) { if (c > bestCount) { bestCount = c; bestKey = k; } }
                    if (!bestKey) return;
                    const [r, g, b] = bestKey.split(',').map(n => parseInt(n, 10));
                    // lighten: convert to HSL and lift lightness
                    const toHsl = (r, g, b) => {
                        r /= 255; g /= 255; b /= 255;
                        const max = Math.max(r, g, b), min = Math.min(r, g, b);
                        let h, s, l = (max + min) / 2;
                        if (max === min) { h = s = 0; }
                        else {
                            const d = max - min;
                            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                            switch (max) {
                                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                                case g: h = (b - r) / d + 2; break;
                                case b: h = (r - g) / d + 4; break;
                            }
                            h /= 6;
                        }
                        return [h, s, l];
                    };
                    const fromHsl = (h, s, l) => {
                        const hue2rgb = (p, q, t) => {
                            if (t < 0) t += 1; if (t > 1) t -= 1;
                            if (t < 1/6) return p + (q - p) * 6 * t;
                            if (t < 1/2) return q;
                            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                            return p;
                        };
                        let r, g, b;
                        if (s === 0) { r = g = b = l; }
                        else {
                            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                            const p = 2 * l - q;
                            r = hue2rgb(p, q, h + 1/3);
                            g = hue2rgb(p, q, h);
                            b = hue2rgb(p, q, h - 1/3);
                        }
                        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
                    };
                    let [h, s, l] = toHsl(r, g, b);
                    l = Math.min(0.85, Math.max(l, 0.6)); // ensure it is light
                    s = Math.min(1.0, s * 1.05);
                    const [lr, lg, lb] = fromHsl(h, s, l);
                    const toHex = (x) => x.toString(16).padStart(2, '0');
                    const hex = '#' + toHex(lr) + toHex(lg) + toHex(lb);
                    // apply to overlay and color picker
                    const previewEl = document.getElementById('gradientPreview');
                    if (previewEl) {
                        previewEl.style.setProperty('--highlight-color', hex);
                        previewEl.style.setProperty('--highlight-color-weak', `rgba(${lr}, ${lg}, ${lb}, 0.35)`);
                        previewEl.style.setProperty('--highlight-color-0', `rgba(${lr}, ${lg}, ${lb}, 0)`);
                    }
                    const picker = document.getElementById('highlightColorPicker');
                    if (picker) picker.value = hex;
                } catch (e) { /* ignore */ }
            }

            generateGradient() {
                if (!this.imageData) return;
                
                const { width, height, data } = this.imageData;
                this.showSpinner();
                
                setTimeout(() => {
                    this.processGradient(width, height, data);
                }, 100);
            }
            
            async processGradient(width, height, data) {
                const details = parseInt(document.getElementById('detailsSlider').value);
                const compression = parseInt(document.getElementById('compressionSlider').value);
                const minified = document.getElementById('minifiedCheckbox').checked;
                const processingMode = document.getElementById('processingModeSelect').value;
                const posterize = parseFloat(document.getElementById('posterizationStrengthSlider').value) / 100;
                const useOriginalPalette = posterize > 0;
                
                try {
                    // Update the core config with current settings
                    this.core.config.selector = '.slick-img-gradient';
                    this.core.config.processing.details = details;
                    this.core.config.processing.compression = compression;
                    this.core.config.processing.mode = processingMode;
                    this.core.config.processing.posterize = posterize;
                    this.core.config.processing.useOriginalPalette = useOriginalPalette;
                    this.core.config.minified = minified;
                    
                    // Set the image data directly
                    this.core.imageData = { width, height, data };
                    
                    // Configure plugins from PluginUI if available
                    if (this.pluginUI) {
                        this.core.config.plugins = this.pluginUI.build();
                    } else {
                        this.core.config.plugins = [];
                    }
                    
                    // Use the new API
                    const css = await this.core.toCSS();
                    
                    this.createGradientPreview(css, width, height);
                    
                    document.getElementById('cssCode').textContent = css;
                    document.getElementById('cssOutput').style.display = 'block';
                    this.hideSpinner();
                } catch (error) {
                    console.error('Error generating gradient:', error);
                    this.hideSpinner();
                    alert('Error generating gradient: ' + error.message);
                }
            }

            createGradientPreview(cssClass, width, height) {
                const preview = document.getElementById('gradientPreview');
                
                // Update the shared CSS class instead of inline styles
                this.updateSharedGradientClass(cssClass);
                // Lighting plugin controls overlay; always include css-lighting
                preview.className = 'slick-img-gradient css-lighting'; // mask-ready intentionally not present until roughness arrives
                
                // Clear any inline styles
                preview.style.width = '';
                preview.style.height = '';
                preview.style.aspectRatio = '';
                preview.style.maxWidth = '';
                preview.style.display = 'block';
                preview.style.border = 'none';
                preview.style.borderRadius = '4px';
                preview.style.maxWidth = '100%';
                preview.style.background = '';
                preview.style.backgroundSize = '';
                preview.style.backgroundRepeat = '';
                preview.style.backgroundPosition = '';
                // Remove fallback min-height once real CSS with aspect-ratio is applied
                preview.style.minHeight = '';
            }

            applyCSSLightingOverlay(enabled) {
                const preview = document.getElementById('gradientPreview');
                if (!preview) return;
                preview.classList.toggle('css-lighting', !!enabled);
            }

            extractBackgroundFromCSS(cssText) {
                if (!cssText) return null;
                const m = cssText.match(/background:\s*([^;]+);/);
                return m ? m[1] : null;
            }

            applyLightingVars(values, isUserChange) {
                try {
                    const gp = document.getElementById('gradientPreview');
                    if (!gp) return;
                    if (values && typeof values === 'object') {
                        // If user is changing values and we're not on custom preset, switch to custom
                        if (isUserChange && values.preset && values.preset !== 'custom') {
                            // Check if any non-preset values have changed from their preset defaults
                            const presetDefaults = {
                                'chrome':         { angle: 170, alpha: 1.0,  blend: 'color-dodge', gap: 110, width: 16, soft: 4, phase: 6, gap2: 80, width2: 10, phase3: 14, gap3: 120, width3: 8 },
                                'water':          { angle: 175, alpha: 0.6,  blend: 'screen',      gap: 160, width: 28, soft: 10, phase: 10, gap2: 120, width2: 16, phase3: 20, gap3: 180, width3: 12 },
                                'wet-paint':      { angle: 35,  alpha: 0.85, blend: 'overlay',     gap: 130, width: 20, soft: 6, phase: 8, gap2: 100, width2: 14, phase3: 18, gap3: 160, width3: 10 },
                                'marble':         { angle: 20,  alpha: 0.7,  blend: 'soft-light',  gap: 180, width: 26, soft: 12, phase: 12, gap2: 150, width2: 18, phase3: 22, gap3: 220, width3: 14 },
                                'brushed-metal':  { angle: 15,  alpha: 0.8,  blend: 'color-dodge', gap: 70,  width: 10, soft: 3, phase: 4, gap2: 60,  width2: 8,  phase3: 9,  gap3: 90,  width3: 6 },
                                'glossy-plastic': { angle: 40,  alpha: 0.75, blend: 'screen',      gap: 120, width: 22, soft: 8, phase: 8, gap2: 95,  width2: 12, phase3: 16, gap3: 150, width3: 10 },
                                'satin':          { angle: 30,  alpha: 0.5,  blend: 'soft-light',  gap: 140, width: 18, soft: 14, phase: 10, gap2: 120, width2: 14, phase3: 20, gap3: 180, width3: 12 },
                                'ceramic':        { angle: 30,  alpha: 0.8,  blend: 'screen',      gap: 150, width: 20, soft: 8, phase: 10, gap2: 120, width2: 14, phase3: 18, gap3: 180, width3: 12 },
                                'clearcoat':      { angle: 171, alpha: 1.0,  blend: 'screen',      gap: 110, width: 50, soft: 4, phase: 2, gap2: 80,  width2: 10, phase3: 14, gap3: 120, width3: 8 },
                                'frosted-glass':  { angle: 170, alpha: 0.4,  blend: 'screen',      gap: 200, width: 30, soft: 16, phase: 12, gap2: 160, width2: 20, phase3: 24, gap3: 220, width3: 14 }
                            };
                            const currentPreset = presetDefaults[values.preset] || presetDefaults['clearcoat'];
                            
                            const hasNonPresetChanges = 
                                (values.lightAngle != null && values.lightAngle != currentPreset.angle) ||
                                (values.highlightAlpha != null && values.highlightAlpha != currentPreset.alpha) ||
                                (values.blendMode && values.blendMode !== currentPreset.blend) ||
                                (values.bandGap != null && values.bandGap != currentPreset.gap) ||
                                (values.bandWidth != null && values.bandWidth != currentPreset.width) ||
                                (values.softEdge != null && values.softEdge != currentPreset.soft) ||
                                (values.bandPhase != null && values.bandPhase != currentPreset.phase) ||
                                (values.bandGap2 != null && values.bandGap2 != currentPreset.gap2) ||
                                (values.bandWidth2 != null && values.bandWidth2 != currentPreset.width2) ||
                                (values.bandPhase3 != null && values.bandPhase3 != currentPreset.phase3) ||
                                (values.bandGap3 != null && values.bandGap3 != currentPreset.gap3) ||
                                (values.bandWidth3 != null && values.bandWidth3 != currentPreset.width3);
                            
                            if (hasNonPresetChanges) {
                                // Switch to custom preset
                                values.preset = 'custom';
                                if (this.pluginUI && this.pluginUI.updateControlValue) {
                                    this.pluginUI.updateControlValue('lighting', 'preset', 'custom');
                                }
                            }
                        }
                        
                        // Apply presets first (they set CSS vars directly; sliders remain as-is)
                        if (values.preset && values.preset !== 'custom') {
                            const P = {
                                'chrome':         { angle: 170, alpha: 1.0,  blend: 'color-dodge', color: '#ffffff', gap: 110, width: 16, soft: 4, phase: 6, gap2: 80, width2: 10, phase3: 14, gap3: 120, width3: 8 },
                                'water':          { angle: 175, alpha: 0.6,  blend: 'screen',      color: '#aee7ff', gap: 160, width: 28, soft: 10, phase: 10, gap2: 120, width2: 16, phase3: 20, gap3: 180, width3: 12 },
                                'wet-paint':      { angle: 35,  alpha: 0.85, blend: 'overlay',     color: '#fff3e0', gap: 130, width: 20, soft: 6, phase: 8, gap2: 100, width2: 14, phase3: 18, gap3: 160, width3: 10 },
                                'marble':         { angle: 20,  alpha: 0.7,  blend: 'soft-light',  color: '#ffffff', gap: 180, width: 26, soft: 12, phase: 12, gap2: 150, width2: 18, phase3: 22, gap3: 220, width3: 14 },
                                'brushed-metal':  { angle: 15,  alpha: 0.8,  blend: 'color-dodge', color: '#ffffff', gap: 70,  width: 10, soft: 3, phase: 4, gap2: 60,  width2: 8,  phase3: 9,  gap3: 90,  width3: 6 },
                                'glossy-plastic': { angle: 40,  alpha: 0.75, blend: 'screen',      color: '#ffd7d7', gap: 120, width: 22, soft: 8, phase: 8, gap2: 95,  width2: 12, phase3: 16, gap3: 150, width3: 10 },
                                'satin':          { angle: 30,  alpha: 0.5,  blend: 'soft-light',  color: '#ffffff', gap: 140, width: 18, soft: 14, phase: 10, gap2: 120, width2: 14, phase3: 20, gap3: 180, width3: 12 },
                                'ceramic':        { angle: 30,  alpha: 0.8,  blend: 'screen',      color: '#ffffff', gap: 150, width: 20, soft: 8, phase: 10, gap2: 120, width2: 14, phase3: 18, gap3: 180, width3: 12 },
                                'clearcoat':      { angle: 171, alpha: 1.0,  blend: 'screen',      color: '#ffffff', gap: 110, width: 50, soft: 4, phase: 2, gap2: 80,  width2: 10, phase3: 14, gap3: 120, width3: 8 },
                                'frosted-glass':  { angle: 170, alpha: 0.4,  blend: 'screen',      color: '#ffffff', gap: 200, width: 30, soft: 16, phase: 12, gap2: 160, width2: 20, phase3: 24, gap3: 220, width3: 14 }
                            };
                            const p = P[String(values.preset)] || null;
                            if (p) {
                                gp.style.setProperty('--light-angle', String(p.angle) + 'deg');
                                gp.style.setProperty('--highlight-alpha', String(p.alpha));
                                gp.style.setProperty('--blend-mode', p.blend);
                                gp.style.setProperty('--band-gap', String(p.gap) + 'px');
                                gp.style.setProperty('--band-width', String(p.width) + 'px');
                                gp.style.setProperty('--soft-edge', String(p.soft) + 'px');
                                gp.style.setProperty('--band-phase', String(p.phase) + 'deg');
                                gp.style.setProperty('--band-gap2', String(p.gap2) + 'px');
                                gp.style.setProperty('--band-width2', String(p.width2) + 'px');
                                gp.style.setProperty('--band-phase3', String(p.phase3) + 'deg');
                                gp.style.setProperty('--band-gap3', String(p.gap3) + 'px');
                                gp.style.setProperty('--band-width3', String(p.width3) + 'px');
                                if (p.color) {
                                    gp.style.setProperty('--highlight-color', String(p.color));
                                    try {
                                        const h = String(p.color).replace('#','');
                                        const r = parseInt(h.substring(0,2),16), g = parseInt(h.substring(2,4),16), b = parseInt(h.substring(4,6),16);
                                        gp.style.setProperty('--highlight-color-soft', `rgba(${r}, ${g}, ${b}, 0.15)`);
                                        gp.style.setProperty('--highlight-color-weak', `rgba(${r}, ${g}, ${b}, 0.35)`);
                                        gp.style.setProperty('--highlight-color-weak2', `rgba(${r}, ${g}, ${b}, 0.2)`);
                                        gp.style.setProperty('--highlight-color-0', `rgba(${r}, ${g}, ${b}, 0)`);
                                    } catch(_) {}
                                }
                                
                                // Update UI control values to match preset when preset is applied
                                if (this.pluginUI && this.pluginUI.updateControlValue) {
                                    this.pluginUI.updateControlValue('lighting', 'lightAngle', p.angle);
                                    this.pluginUI.updateControlValue('lighting', 'highlightAlpha', p.alpha);
                                    this.pluginUI.updateControlValue('lighting', 'blendMode', p.blend);
                                    this.pluginUI.updateControlValue('lighting', 'bandGap', p.gap);
                                    this.pluginUI.updateControlValue('lighting', 'bandWidth', p.width);
                                    this.pluginUI.updateControlValue('lighting', 'softEdge', p.soft);
                                    this.pluginUI.updateControlValue('lighting', 'bandPhase', p.phase);
                                    this.pluginUI.updateControlValue('lighting', 'bandGap2', p.gap2);
                                    this.pluginUI.updateControlValue('lighting', 'bandWidth2', p.width2);
                                    this.pluginUI.updateControlValue('lighting', 'bandPhase3', p.phase3);
                                    this.pluginUI.updateControlValue('lighting', 'bandGap3', p.gap3);
                                    this.pluginUI.updateControlValue('lighting', 'bandWidth3', p.width3);
                                }
                            }
                        }
                        if (values.lightAngle != null) gp.style.setProperty('--light-angle', String(values.lightAngle) + 'deg');
                        if (values.highlightAlpha != null) gp.style.setProperty('--highlight-alpha', String(parseFloat(values.highlightAlpha)));
                        if (values.blendMode) gp.style.setProperty('--blend-mode', String(values.blendMode));
                        if (values.bandGap != null) gp.style.setProperty('--band-gap', String(values.bandGap) + 'px');
                        if (values.bandWidth != null) gp.style.setProperty('--band-width', String(values.bandWidth) + 'px');
                        if (values.softEdge != null) gp.style.setProperty('--soft-edge', String(values.softEdge) + 'px');
                        if (values.bandPhase != null) gp.style.setProperty('--band-phase', String(values.bandPhase) + 'deg');
                        if (values.bandGap2 != null) gp.style.setProperty('--band-gap2', String(values.bandGap2) + 'px');
                        if (values.bandWidth2 != null) gp.style.setProperty('--band-width2', String(values.bandWidth2) + 'px');
                        if (values.bandPhase3 != null) gp.style.setProperty('--band-phase3', String(values.bandPhase3) + 'deg');
                        if (values.bandGap3 != null) gp.style.setProperty('--band-gap3', String(values.bandGap3) + 'px');
                        if (values.bandWidth3 != null) gp.style.setProperty('--band-width3', String(values.bandWidth3) + 'px');
                        // Color picker from plugin
                        if (values.color) {
                            const hex = String(values.color);
                            gp.style.setProperty('--highlight-color', hex);
                            try {
                                const h = hex.replace('#','');
                                const r = parseInt(h.substring(0,2),16), g = parseInt(h.substring(2,4),16), b = parseInt(h.substring(4,6),16);
                                gp.style.setProperty('--highlight-color-soft', `rgba(${r}, ${g}, ${b}, 0.15)`);
                                gp.style.setProperty('--highlight-color-weak', `rgba(${r}, ${g}, ${b}, 0.35)`);
                                gp.style.setProperty('--highlight-color-weak2', `rgba(${r}, ${g}, ${b}, 0.2)`);
                                gp.style.setProperty('--highlight-color-0', `rgba(${r}, ${g}, ${b}, 0)`);
                            } catch(_) {}
                        }
                        // Preview masking toggle
                        if (values.preview) {
                            if (values.preview === 'unmasked') {
                                // Show only the lighting overlay without masking on black
                                gp.style.setProperty('--lighting-mask', 'none');
                                gp.classList.add('lighting-only');
                                gp.classList.add('lighting-unmasked');
                                gp.classList.remove('lighting-masked');
                                gp.classList.remove('show-mask');
                                // Remove base gradient entirely and force black bg
                                try { gp.style.setProperty('background', 'none', 'important'); } catch(_) {}
                                try { gp.style.setProperty('background-color', '#000', 'important'); } catch(_) {}
                            } else if (values.preview === 'masked') {
                                // Show only the masked lighting overlay on black
                                gp.style.setProperty('--lighting-mask', 'var(--spec-mask)');
                                gp.classList.add('lighting-only');
                                gp.classList.add('lighting-masked');
                                gp.classList.remove('lighting-unmasked');
                                gp.classList.remove('show-mask');
                                // Remove base gradient entirely and force black bg
                                try { gp.style.setProperty('background', 'none', 'important'); } catch(_) {}
                                try { gp.style.setProperty('background-color', '#000', 'important'); } catch(_) {}
                            } else if (values.preview === 'mask-only') {
                                // Visualize the mask image directly (roughness) on black
                                gp.classList.add('lighting-only');
                                gp.classList.add('show-mask');
                                gp.classList.remove('lighting-masked');
                                gp.classList.remove('lighting-unmasked');
                                // Ensure background is black and base gradient is gone
                                try { gp.style.setProperty('background', 'none', 'important'); } catch(_) {}
                                try { gp.style.setProperty('background-color', '#000', 'important'); } catch(_) {}
                                // Ensure we have a concrete mask visual available
                                try {
                                    const dataURL = (this.lastMapData && this.lastMapData.roughness) ? this.lastMapData.roughness : null;
                                    if (dataURL) {
                                        const urlDecl = 'url("' + dataURL + '") left top / 100% 100% no-repeat';
                                        gp.style.setProperty('--mask-visual', urlDecl);
                                    }
                                } catch (_) {}
                            } else { // off
                                gp.style.removeProperty('--lighting-mask');
                                gp.classList.remove('lighting-only');
                                gp.classList.remove('lighting-unmasked');
                                gp.classList.remove('lighting-masked');
                                gp.classList.remove('show-mask');
                                // Respect showMask state if it is set separately
                                // Restore base element defaults
                                gp.style.removeProperty('background');
                                gp.style.removeProperty('background-color');
                            }
                        }
                        // No separate showMask toggle anymore; moved into Preview dropdown
                        // Enable/disable overlay class
                        if (typeof values.enabled !== 'undefined') {
                            gp.classList.toggle('css-lighting', !!values.enabled);
                        }
                    }
                } catch (_) {}
            }

            updateSharedGradientClass(cssClass) {
                // Update or create the shared CSS class for both preview and background
                let styleElement = document.getElementById('shared-gradient-style');
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = 'shared-gradient-style';
                    document.head.appendChild(styleElement);
                }
                
                styleElement.textContent = cssClass;
            }

            updateSpecGradientClass(cssClass) {
                // Update or create the specular map CSS class
                let styleElement = document.getElementById('spec-map-style');
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = 'spec-map-style';
                    document.head.appendChild(styleElement);
                }
                
                styleElement.textContent = cssClass;
            }

            

            updateNormalGradientClass(cssClass) {
                // Update or create the normal map CSS class
                let styleElement = document.getElementById('normal-map-style');
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = 'normal-map-style';
                    document.head.appendChild(styleElement);
                }
                
                // Extract aspect ratio from the CSS and apply it to the preview div
                const aspectRatioMatch = cssClass.match(/aspect-ratio:\s*(\d+)\s*\/\s*(\d+)/);
                if (aspectRatioMatch) {
                    const ratio = `${aspectRatioMatch[1]} / ${aspectRatioMatch[2]}`;
                    const normalDiv = document.getElementById('normalGradientPreview');
                    if (normalDiv) {
                        normalDiv.style.aspectRatio = ratio;
                    }
                }
                
                styleElement.textContent = cssClass;
            }

            updateRoughnessGradientClass(cssClass) {
                // Update or create the roughness map CSS class
                let styleElement = document.getElementById('roughness-map-style');
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = 'roughness-map-style';
                    document.head.appendChild(styleElement);
                }
                
                // Extract aspect ratio from the CSS and apply it to the preview div
                const aspectRatioMatch = cssClass.match(/aspect-ratio:\s*(\d+)\s*\/\s*(\d+)/);
                if (aspectRatioMatch) {
                    const ratio = `${aspectRatioMatch[1]} / ${aspectRatioMatch[2]}`;
                    const roughnessDiv = document.getElementById('roughnessGradientPreview');
                    if (roughnessDiv) {
                        roughnessDiv.style.aspectRatio = ratio;
                    }
                }
                
                styleElement.textContent = cssClass;
            }

            updateSubjectNormalGradientClass(cssClass) {
                // Update or create the subject normal map CSS class
                let styleElement = document.getElementById('subjectnormal-map-style');
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = 'subjectnormal-map-style';
                    document.head.appendChild(styleElement);
                }
                
                // Extract aspect ratio from the CSS and apply it to the preview div
                const aspectRatioMatch = cssClass.match(/aspect-ratio:\s*(\d+)\s*\/\s*(\d+)/);
                if (aspectRatioMatch) {
                    const ratio = `${aspectRatioMatch[1]} / ${aspectRatioMatch[2]}`;
                    const subjectnormalDiv = document.getElementById('subjectnormalGradientPreview');
                    if (subjectnormalDiv) {
                        subjectnormalDiv.style.aspectRatio = ratio;
                    }
                }
                
                styleElement.textContent = cssClass;
            }

            updateMapPreviewVisibility() {
                // Always hide all extractor map previews, regardless of enabled state
                try {
                    const allSections = [
                      'normalPreviewSection', 'roughnessPreviewSection', 'subjectnormalPreviewSection',
                      'albedoPreviewSection', 'depthPreviewSection', 'objectPreviewSection', 'irradiancePreviewSection'
                    ];
                    allSections.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.style.display = 'none';
                    });
                } catch (e) {
                    console.warn('Error updating map preview visibility:', e);
                }
            }

            updateBodyBackground(css, width, height) {
                // The CSS class is already updated by updateSharedGradientClass
                // We just need to create/activate the background element
                
                // Create or get the gradient background element
                let gradientEl = document.getElementById('gradient-background');
                if (!gradientEl) {
                    gradientEl = document.createElement('div');
                    gradientEl.id = 'gradient-background';
                    gradientEl.className = 'gradient-background slick-img-gradient';
                    document.body.appendChild(gradientEl);
                } else {
                    // Ensure it has the gradient class
                    gradientEl.className = 'gradient-background slick-img-gradient';
                }
                
                console.log('Background element updated with shared CSS class');
                
                // Activate the background
                gradientEl.classList.add('active');
            }

            
            async findOptimalSettings(preserveParameter = null) {
                try {
                    const maxSizeInput = document.getElementById('maxSizeInput');
                    const maxSizeText = maxSizeInput ? maxSizeInput.value.trim() : '';
                    
                    if (maxSizeText) {
                        this.core.config.maxSize = maxSizeText;
                    } else {
                        this.core.config.maxSize = null;
                    }
                    
                    const optimal = await this.core.findOptimalSettingsForImage(preserveParameter);
                    this.displayOptimizationResults(optimal);
                } catch (error) {
                    console.error('Optimization error:', error);
                }
            }
            
            displayOptimizationResults(optimal) {
                const detailsSlider = document.getElementById('detailsSlider');
                const detailsValue = document.getElementById('detailsValue');
                const compressionSlider = document.getElementById('compressionSlider');
                const compressionValue = document.getElementById('compressionValue');
                
                // Update sliders
                if(!this.firstLoad){
					detailsSlider.value = optimal.details;
	                detailsValue.textContent = optimal.details;
	                compressionSlider.value = optimal.compression;
	                compressionValue.textContent = optimal.compression;
	                this.updateStats();
				}

                
                
                // Show optimal hints inline
                this.showOptimalHints(optimal.details, optimal.compression);
            }
            
            showOptimalHints(optimalDetails, optimalCompression) {
                const detailsHint = document.getElementById('optimalDetails');
                const compressionHint = document.getElementById('optimalCompression');
                
                detailsHint.textContent = `(optimal: ${optimalDetails}%)`;
                detailsHint.style.display = 'inline';
                
                compressionHint.textContent = `(optimal: ${optimalCompression}%)`;
                compressionHint.style.display = 'inline';
                
                // Keep hints visible permanently
            }

            updateStats() {
                if (!this.imageData) return;
                const details = parseInt(document.getElementById('detailsSlider').value);
                const { width, height } = this.imageData;
                this.showStats(width, height, details);
            }

            showStats(width, height, details = 100) {
                const pixels = width * height;
                const compression = parseInt(document.getElementById('compressionSlider').value);
                
                // Calculate scaled dimensions
                const scaleFactor = details / 100;
                const scaledWidth = scaleFactor >= 1.0 ? width : Math.max(1, Math.round(width * scaleFactor));
                const scaledHeight = scaleFactor >= 1.0 ? height : Math.max(1, Math.round(height * scaleFactor));
                
                // Determine orientation
                const isLandscape = width > height;
                const orientation = isLandscape ? 'Landscape' : 'Portrait';
                
                // Calculate total reduction
                const baseSamplingRate = 100 / details;
                const baseReduction = (compression / 100) * 0.6;
                const adjustedSamplingRate = baseSamplingRate * (1 + baseReduction);
                const sampledPixels = Math.ceil(scaledWidth / adjustedSamplingRate) * Math.ceil(scaledHeight / adjustedSamplingRate);
                const totalReduction = ((pixels - sampledPixels) / pixels * 100).toFixed(1);
                
                // Get CSS size estimate
                const minified = document.getElementById('minifiedCheckbox').checked;
                const cssEstimate = this.estimateCSSSize(width, height, details, compression, minified);
                
                // Basic stats
                const scalingInfo = scaleFactor < 1.0 ? 
                    `${scaledWidth} √ó ${scaledHeight} pixels` : 'Not scaled';
                
                document.getElementById('statsContent').innerHTML = `
                    <strong>Dimensions:</strong> ${width} √ó ${height} pixels (${pixels.toLocaleString()} total)<br>
                    <strong>Scaled for Processing:</strong> ${scalingInfo}<br>
                    <strong>Orientation:</strong> ${orientation}<br>
                    <strong>Total Reduction:</strong> ${totalReduction}%<br>
                    <strong>Estimated Size:</strong> ${this.formatFileSize(cssEstimate.cssSizeKB)}
                `;
                
                // Detailed stats (initially hidden)
                const useRows = isLandscape;
                const modeText = useRows ? 'rows' : 'columns';
                const gradientDirection = useRows ? 'horizontal' : 'vertical';
                
                const baseBlur = 2;
                const exponentialFactor = Math.pow(adjustedSamplingRate, 0.5);
                const blurRadius = Math.max(1, Math.floor(baseBlur * exponentialFactor));
                
                const uniqueStripes = useRows ? 
                    Math.ceil(scaledHeight / adjustedSamplingRate) : 
                    Math.ceil(scaledWidth / adjustedSamplingRate);
                
                const colorThreshold = (compression / 100) * 30;
                const baseColorStops = uniqueStripes * (useRows ? 
                    Math.ceil(scaledWidth / adjustedSamplingRate) : 
                    Math.ceil(scaledHeight / adjustedSamplingRate));
                
                const complexityFactor = Math.min(width, height) > 500 ? 1.2 : 1.0;
                const colorOptimizationPercent = compression === 0 ? 0 : 
                    Math.min(60, (compression / 100) * 50 * complexityFactor);
                const finalColorStops = Math.round(baseColorStops * (1 - colorOptimizationPercent / 100));
                
                document.getElementById('statsDetailed').innerHTML = `
                    <strong>Processing Details:</strong><br>
                    Base sampling: Every ${baseSamplingRate.toFixed(1)} pixels<br>
                    2D Gaussian blur: ${blurRadius}px radius<br>
                    Processing mode: ${modeText} (${gradientDirection} gradients)<br>
                    Adjusted sampling rate: 1:${adjustedSamplingRate.toFixed(1)}<br><br>
                    
                    <strong>Compression Analysis:</strong><br>
                    ${modeText.charAt(0).toUpperCase() + modeText.slice(1)} reduction: ${(baseReduction * 100).toFixed(1)}%<br>
                    Color threshold: ${colorThreshold.toFixed(1)} RGB units<br>
                    Color optimization: ${colorOptimizationPercent.toFixed(1)}%<br><br>
                    
                    <strong>Output Estimation:</strong><br>
                    Estimated ${modeText}: ${uniqueStripes.toLocaleString()}<br>
                    Before color optimization: ~${baseColorStops.toLocaleString()} color stops<br>
                    After color optimization: ~${finalColorStops.toLocaleString()} color stops<br>
                    CSS method: ${useRows ? 'Row-based processing' : 'Column-based processing'}
                `;
            }

            copyCSS() {
                const cssCode = document.getElementById('cssCode').textContent;
                navigator.clipboard.writeText(cssCode).then(() => {
                    const btn = document.getElementById('copyBtn');
                    const icon = btn.querySelector('.copy-icon');
                    
                    // Add copied class for visual feedback
                    btn.classList.add('copied');
                    btn.title = 'Copied!';
                    
                    // Change to checkmark
                    icon.textContent = '‚úì';
                    
                    setTimeout(() => {
                        btn.classList.remove('copied');
                        btn.title = 'Copy CSS';
                        // Change back to copy icon
                        icon.textContent = '‚éò';
                    }, 2000);
                }).catch(() => {
                    alert('Failed to copy to clipboard. Please select and copy manually.');
                });
            }
            
            async autoAdjustForMaxSize(preserveSlider = null) {
                if (!this.imageData) return false;
                
                const maxSizeInput = document.getElementById('maxSizeInput');
                const maxSizeText = maxSizeInput ? maxSizeInput.value.trim() : '';
                
                if (!maxSizeText) return false;
                
                this.core.config.maxSize = maxSizeText;
                const maxSizeKB = this.parseMaxSizeToKB(maxSizeText);
                
                if (!maxSizeKB || maxSizeKB <= 0) return false;
                
                const { width, height } = this.imageData;
                const currentDetails = parseInt(document.getElementById('detailsSlider').value);
                const currentCompression = parseInt(document.getElementById('compressionSlider').value);
                
                const currentSize = this.estimateCSSSize(width, height, currentDetails, currentCompression).cssSizeKB;
                
                if (currentSize <= maxSizeKB) return false;
                
                if (preserveSlider === 'details') {
                    for (let compression = currentCompression; compression <= 100; compression += 1) {
                        const testSize = this.estimateCSSSize(width, height, currentDetails, compression).cssSizeKB;
                        if (testSize <= maxSizeKB) {
                            if (compression !== currentCompression) {
                                document.getElementById('compressionSlider').value = compression;
                                document.getElementById('compressionValue').textContent = compression;
                                return true;
                            }
                            return false;
                        }
                    }
                    return false;
                }
                
                if (preserveSlider === 'compression') {
                    for (let details = currentDetails; details >= 1; details -= 1) {
                        const testSize = this.estimateCSSSize(width, height, details, currentCompression).cssSizeKB;
                        if (testSize <= maxSizeKB) {
                            if (details !== currentDetails) {
                                document.getElementById('detailsSlider').value = details;
                                document.getElementById('detailsValue').textContent = details;
                                return true;
                            }
                            return false;
                        }
                    }
                    return false;
                }
                
                return false;
            }



            copyCSS() {
                const cssCode = document.getElementById('cssCode').textContent;
                if (!cssCode) {
                    alert('No CSS to copy. Please generate a gradient first.');
                    return;
                }
                
                navigator.clipboard.writeText(cssCode).then(() => {
                    // Temporarily change button text
                    const btn = document.getElementById('copyBtn');
                    const originalText = btn.textContent;
                    btn.textContent = 'Copied!';
                    setTimeout(() => {
                        btn.textContent = originalText;
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy CSS: ', err);
                    // Fallback - select the text
                    const cssElement = document.getElementById('cssCode');
                    const range = document.createRange();
                    range.selectNode(cssElement);
                    window.getSelection().removeAllRanges();
                    window.getSelection().addRange(range);
                    alert('CSS selected. Please copy manually with Ctrl+C or Cmd+C');
                });
            }

            downloadMapCSS(mapType) {
                let cssCode = '', filename = '';
                if (mapType === 'specular') {
                    cssCode = document.getElementById('specCssCode').textContent;
                    filename = 'specularity-from-roughness.css';
                } else if (mapType === 'normal') {
                    cssCode = document.getElementById('normalCssCode').textContent;
                    filename = 'normal-map.css';
                } else if (mapType === 'roughness') {
                    cssCode = document.getElementById('roughCssCode').textContent;
                    filename = 'roughness-map.css';
                } else if (mapType === 'subjectnormal') {
                    cssCode = document.getElementById('subjectnormalCssCode').textContent;
                    filename = 'subject-normal-map.css';
                } else if (mapType === 'reflViaSubjectnormal') {
                    cssCode = document.getElementById('reflFromSubjectnormalCssCode').textContent;
                    filename = 'reflection-from-subjectnormal.css';
                } else {
                    alert('Unknown map type: ' + mapType);
                    return;
                }
                
                if (!cssCode) {
                    alert(`No ${mapType} CSS to download. Please generate a gradient first and ensure the ${mapType} map is enabled.`);
                    return;
                }
                
                const blob = new Blob([cssCode], { type: 'text/css' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            downloadAllMaps() {
                // Collect all available map CSS
                const maps = [];
                
                const specCSS = document.getElementById('specCssCode').textContent;
                if (specCSS) maps.push({ name: 'specularity-from-roughness.css', content: specCSS });
                
                const normalCSS = document.getElementById('normalCssCode').textContent;
                if (normalCSS) maps.push({ name: 'normal-map.css', content: normalCSS });

                const roughCSS = document.getElementById('roughCssCode').textContent;
                if (roughCSS) maps.push({ name: 'roughness-map.css', content: roughCSS });

                const subjNormCSS = document.getElementById('subjectnormalCssCode').textContent;
                if (subjNormCSS) maps.push({ name: 'subject-normal-map.css', content: subjNormCSS });
                const reflViaSubjCSS = document.getElementById('reflFromSubjectnormalCssCode').textContent;
                if (reflViaSubjCSS) maps.push({ name: 'reflection-from-subjectnormal.css', content: reflViaSubjCSS });
                
                const mainCSS = document.getElementById('cssCode').textContent;
                if (mainCSS) maps.push({ name: 'main-gradient.css', content: mainCSS });
                
                if (maps.length === 0) {
                    alert('No CSS maps to download. Please generate gradients first.');
                    return;
                }
                
                // Download each map
                maps.forEach(map => {
                    const blob = new Blob([map.content], { type: 'text/css' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = map.name;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
            }
        }
        
       
        
        document.addEventListener('DOMContentLoaded', () => {
            window.converter = new img2cssUI({

            	/* DO NOT DELETE COMMENTED OUT OPTIONS - USED FOR TESTING */
                
                /*
                source: 'https://i.imgur.com/Qc3TD8h.jpeg',
				compression: 0,
                details: 80
                */


                source: 'https://i.imgur.com/QFnqULE.png',
                //autoOptimize: false,
                compression: 0,
                details: 48
            });
        });
        
        
    </script>
</body>
</html>
