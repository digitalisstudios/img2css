<!DOCTYPE html>
<html>
<head>
    <title>img2css v2.0 - Callback System Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #222;
            color: white;
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            color: #4CAF50;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .demo-explanation {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #4CAF50;
            margin-bottom: 30px;
        }
        
        .demo-explanation h3 {
            color: #4CAF50;
            margin-top: 0;
        }
        
        .controls {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #555;
            margin-bottom: 20px;
        }
        
        .file-input {
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 10px;
            border-radius: 4px;
            width: 100%;
            margin-bottom: 20px;
        }
        
        .generate-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            margin-bottom: 20px;
        }
        
        .generate-btn:hover {
            background: #45a049;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .result-container {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #555;
        }
        
        .result-container h3 {
            color: #4CAF50;
            margin-top: 0;
            text-align: center;
        }
        
        .blend-demo {
            width: 100%;
            height: 300px;
            position: relative;
            border: 2px solid #666;
            border-radius: 8px;
            overflow: hidden;
            margin: 0 auto;
            background: #000;
        }
        
        .blend-demo.auto-aspect {
            height: auto;
            aspect-ratio: var(--image-aspect-ratio, 1);
        }
        
        .layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .layer-base {
            background: var(--generated-gradient, #999);
        }
        
        .shader {
            position: relative;
            overflow: hidden;
            backface-visibility: hidden;
        }
        
        .shader__layer {
            background: black;
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-size: 100%;
            pointer-events: none;
        }
        
        #layerToneSpecular {
            mix-blend-mode: color-dodge;
            background: transparent;
        }
        
        #layerToneReflection {
            mix-blend-mode: soft-light;
            background: transparent;
        }
        
        #layerToneShadow {
            mix-blend-mode: multiply;
            background: transparent;
        }
        
        .gradient-with-mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            -webkit-mask-size: 100% 100%;
            mask-size: 100% 100%;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
        }
        
        .layer-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }
        
        .layer-toggle {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .layer-toggle.disabled {
            background: #666;
        }
        
        .layer-toggle:hover:not(.disabled) {
            background: #45a049;
        }
        
        .effect-controls {
            background: #444;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .control-group {
            display: grid;
            grid-template-columns: auto 60px auto 50px;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
            font-size: 12px;
        }
        
        .control-group-extended {
            display: grid;
            grid-template-columns: auto 50px 50px auto 50px 100px 60px;
            gap: 8px;
            align-items: center;
            margin-bottom: 10px;
            font-size: 12px;
        }
        
        .blend-mode-select {
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
        }
        
        .blend-mode-select:focus {
            outline: none;
            border-color: #4CAF50;
        }
        
        .invert-btn {
            background: #666;
            color: white;
            border: none;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            transition: background 0.2s;
        }
        
        .invert-btn:hover {
            background: #777;
        }
        
        .invert-btn.active {
            background: #ff6b6b;
        }
        
        .control-group label {
            color: #ccc;
        }
        
        .control-group input[type="color"] {
            width: 50px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .control-group input[type="range"] {
            width: 100%;
        }
        
        .control-group span {
            color: #4CAF50;
            font-weight: bold;
            text-align: center;
        }
        
        .masks-preview {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        
        .mask-preview {
            background: #444;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .mask-preview h4 {
            color: #4CAF50;
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        
        .mask-canvas {
            width: 100%;
            max-width: 200px;
            border: 1px solid #666;
            border-radius: 4px;
        }
        
        .stats {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #555;
            margin-bottom: 20px;
        }
        
        .stats h3 {
            color: #4CAF50;
            margin-top: 0;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-family: monospace;
            font-size: 14px;
        }
        
        .log-container {
            background: #1e1e1e;
            color: #ccc;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.3;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            border: 1px solid #444;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß img2css v2.0 - Callback System Demo</h1>
        <p style="text-align: center; color: #ccc; margin-bottom: 30px;">
            Demonstrating the new plugin system with perfect tone mask alignment
        </p>
        
        <div class="demo-explanation">
            <h3>üéØ Plugin System Architecture</h3>
            <p><strong>Perfect Alignment Approach:</strong> Use img2css callbacks to capture pixel data during actual gradient generation</p>
            <ul>
                <li><strong>onPixelProcess:</strong> Fires for every pixel sampled during gradient generation</li>
                <li><strong>onRowProcess:</strong> Fires after each row is processed (landscape mode)</li>
                <li><strong>onColumnProcess:</strong> Fires after each column is processed (portrait mode)</li>
            </ul>
            <p><em>This ensures tone masks are generated from the exact same sampling points as the base gradient!</em></p>
        </div>
        
        <div class="controls">
            <h3>üéõÔ∏è Generate with Plugin System</h3>
            <input type="file" id="imageInput" class="file-input" accept="image/*">
            <button id="generateBtn" class="generate-btn" onclick="generateWithCallbacks()">
                üöÄ Generate with Tone Analysis Plugin
            </button>
        </div>
        
        <div class="results-grid">
            <div class="result-container">
                <h3>üé® Base img2css Gradient</h3>
                <div class="blend-demo auto-aspect" id="baseDemo">
                    <div class="layer layer-base" id="layerBase"></div>
                </div>
                <p style="text-align: center; color: #999; font-size: 12px; margin-top: 10px;">
                    Generated using standard img2css processing
                </p>
            </div>
            
            <div class="result-container">
                <h3>‚ú® Enhanced with Plugin Tone Masks</h3>
                <div class="blend-demo auto-aspect shader" id="enhancedDemo">
                    <div class="layer layer-base" id="layerBaseEnhanced"></div>
                    <div class="layer shader__layer specular" id="layerToneSpecular">
                        <div class="gradient-with-mask" id="specularGradient"></div>
                    </div>
                    <div class="layer shader__layer reflection" id="layerToneReflection">
                        <div class="gradient-with-mask" id="reflectionGradient"></div>
                    </div>
                    <div class="layer shader__layer shadow" id="layerToneShadow">
                        <div class="gradient-with-mask" id="shadowGradient"></div>
                    </div>
                </div>
                
                <div class="layer-controls">
                    <button class="layer-toggle" onclick="toggleLayer('layerBaseEnhanced')">Base</button>
                    <button class="layer-toggle" onclick="toggleLayer('layerToneSpecular')">Specular</button>
                    <button class="layer-toggle" onclick="toggleLayer('layerToneReflection')">Reflection</button>
                    <button class="layer-toggle" onclick="toggleLayer('layerToneShadow')">Shadow</button>
                </div>
                
                <div class="effect-controls">
                    <h4 style="color: #4CAF50; margin: 20px 0 10px 0;">üé® Effect Customization</h4>
                    
                    <div class="control-group-extended">
                        <label>Specular Gradient:</label>
                        <input type="color" id="specularColor1" value="#ffffff" onchange="updateEffects()">
                        <input type="color" id="specularColor2" value="#ffffcc" onchange="updateEffects()">
                        <label>Opacity: <span id="specularOpacityValue">0.2</span></label>
                        <input type="range" id="specularOpacity" min="0" max="1" step="0.1" value="0.2" oninput="updateEffects()">
                        <select class="blend-mode-select" id="specularBlendMode" onchange="updateEffects()">
                            <option value="color-dodge" selected>color-dodge</option>
                            <option value="screen">screen</option>
                            <option value="lighten">lighten</option>
                            <option value="plus-lighter">plus-lighter</option>
                            <option value="overlay">overlay</option>
                            <option value="hard-light">hard-light</option>
                            <option value="soft-light">soft-light</option>
                            <option value="normal">normal</option>
                        </select>
                        <button class="invert-btn" id="specularInvert" onclick="toggleInvert('specular')">Invert</button>
                    </div>
                    
                    <div class="control-group-extended">
                        <label>Reflection Gradient:</label>
                        <input type="color" id="reflectionColor1" value="#c8dcff" onchange="updateEffects()">
                        <input type="color" id="reflectionColor2" value="#ffffff" onchange="updateEffects()">
                        <label>Opacity: <span id="reflectionOpacityValue">0.2</span></label>
                        <input type="range" id="reflectionOpacity" min="0" max="1" step="0.1" value="0.2" oninput="updateEffects()">
                        <select class="blend-mode-select" id="reflectionBlendMode" onchange="updateEffects()">
                            <option value="soft-light" selected>soft-light</option>
                            <option value="overlay">overlay</option>
                            <option value="hard-light">hard-light</option>
                            <option value="color-dodge">color-dodge</option>
                            <option value="screen">screen</option>
                            <option value="lighten">lighten</option>
                            <option value="normal">normal</option>
                        </select>
                        <button class="invert-btn" id="reflectionInvert" onclick="toggleInvert('reflection')">Invert</button>
                    </div>
                    
                    <div class="control-group-extended">
                        <label>Shadow Gradient:</label>
                        <input type="color" id="shadowColor1" value="#000000" onchange="updateEffects()">
                        <input type="color" id="shadowColor2" value="#333333" onchange="updateEffects()">
                        <label>Opacity: <span id="shadowOpacityValue">0.3</span></label>
                        <input type="range" id="shadowOpacity" min="0" max="1" step="0.1" value="0.3" oninput="updateEffects()">
                        <select class="blend-mode-select" id="shadowBlendMode" onchange="updateEffects()">
                            <option value="multiply" selected>multiply</option>
                            <option value="color-burn">color-burn</option>
                            <option value="darken">darken</option>
                            <option value="overlay">overlay</option>
                            <option value="hard-light">hard-light</option>
                            <option value="soft-light">soft-light</option>
                            <option value="normal">normal</option>
                        </select>
                        <button class="invert-btn" id="shadowInvert" onclick="toggleInvert('shadow')">Invert</button>
                    </div>
                </div>
                
                <div class="masks-preview">
                    <div class="mask-preview">
                        <h4>Specular Mask</h4>
                        <canvas id="specularMaskCanvas" class="mask-canvas"></canvas>
                    </div>
                    <div class="mask-preview">
                        <h4>Reflection Mask</h4>
                        <canvas id="reflectionMaskCanvas" class="mask-canvas"></canvas>
                    </div>
                    <div class="mask-preview">
                        <h4>Shadow Mask</h4>
                        <canvas id="shadowMaskCanvas" class="mask-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="stats">
            <h3>üìä Plugin Processing Statistics</h3>
            <div id="statsContent">
                Load an image and generate to see plugin processing statistics
            </div>
        </div>
        
        <div id="logContainer" class="log-container"></div>
    </div>

    <script src="src/img2css.js"></script>
    <script>
        let originalImageData = null;
        let toneMaskData = null;
        let processingStats = null;
        
        // Tone analysis plugin data
        let specularPixels = [];
        let reflectionPixels = [];
        let shadowPixels = [];
        let totalPixelsProcessed = 0;
        let totalRowsProcessed = 0;
        let totalColumnsProcessed = 0;
        
        // Invert states for each mask
        let maskInvertStates = {
            specular: false,
            reflection: false,
            shadow: false
        };
        
        function log(message) {
            const logEl = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            logEl.innerHTML += `[${timestamp}] ${message}\n`;
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        // Handle file input
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                loadImageFile(file);
            }
        });
        
        function loadImageFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    processImage(img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function processImage(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size (maintain aspect ratio)
            const maxWidth = 800;
            const maxHeight = 600;
            let { width, height } = img;
            
            if (width > maxWidth) {
                height = (height * maxWidth) / width;
                width = maxWidth;
            }
            if (height > maxHeight) {
                width = (width * maxHeight) / height;
                height = maxHeight;
            }
            
            canvas.width = width;
            canvas.height = height;
            
            ctx.drawImage(img, 0, 0, width, height);
            originalImageData = ctx.getImageData(0, 0, width, height);
            
            // Set the aspect ratio for both demo containers
            const aspectRatio = width / height;
            document.documentElement.style.setProperty('--image-aspect-ratio', aspectRatio);
            
            document.getElementById('generateBtn').disabled = false;
            log(`Image loaded: ${width}x${height} (aspect ratio: ${aspectRatio.toFixed(2)})`);
        }
        
        async function generateWithCallbacks() {
            if (!originalImageData) {
                alert('Please load an image first!');
                return;
            }
            
            log('üöÄ Starting img2css generation with plugin callbacks...');
            
            // Reset plugin data
            specularPixels = [];
            reflectionPixels = [];
            shadowPixels = [];
            totalPixelsProcessed = 0;
            totalRowsProcessed = 0;
            totalColumnsProcessed = 0;
            
            // Create blob URL from image data
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = originalImageData.width;
            canvas.height = originalImageData.height;
            ctx.putImageData(originalImageData, 0, 0);
            
            canvas.toBlob(async (blob) => {
                const imageUrl = URL.createObjectURL(blob);
                
                try {
                    log('üìä Generating CSS with tone analysis...');
                    
                    // Create img2css instance with callbacks and source
                    const img2cssInstance = new img2css({
                        source: imageUrl,
                        onPixelProcess: onPixelProcessCallback,
                        onRowProcess: onRowProcessCallback,
                        onColumnProcess: onColumnProcessCallback
                    });
                    
                    // Generate CSS (this will trigger all our callbacks)
                    const cssResult = await img2cssInstance.toCSS();
                    
                    log(`‚úÖ Generation complete! Processed ${totalPixelsProcessed} pixels, ${totalRowsProcessed} rows, ${totalColumnsProcessed} columns`);
                    
                    // Apply base gradient
                    applyBaseGradient(cssResult);
                    
                    // Generate tone masks from captured data
                    const masks = generateToneMasksFromCallbackData();
                    
                    // Apply enhanced layers
                    applyEnhancedLayers(masks);
                    
                    // Update statistics
                    updateStats();
                    
                    // Clean up
                    URL.revokeObjectURL(imageUrl);
                    
                } catch (error) {
                    log(`‚ùå Error: ${error.message}`);
                }
            });
        }
        
        function onPixelProcessCallback(pixelData) {
            totalPixelsProcessed++;
            
            // Classify pixel by tone (same logic as previous prototypes)
            const { r, g, b } = pixelData;
            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
            
            const specularThreshold = 180; // Lowered to catch more highlights
            const shadowThreshold = 80;
            
            if (gray >= specularThreshold) {
                specularPixels.push({
                    x: pixelData.x,
                    y: pixelData.y,
                    intensity: gray / 255,
                    position: pixelData.position,
                    isRow: pixelData.isRow
                });
            } else if (gray <= shadowThreshold) {
                shadowPixels.push({
                    x: pixelData.x,
                    y: pixelData.y,
                    intensity: (255 - gray) / 255,
                    position: pixelData.position,
                    isRow: pixelData.isRow
                });
            } else {
                reflectionPixels.push({
                    x: pixelData.x,
                    y: pixelData.y,
                    intensity: (Math.abs(gray - 127.5) / 127.5),
                    position: pixelData.position,
                    isRow: pixelData.isRow
                });
            }
        }
        
        function onRowProcessCallback(rowData) {
            totalRowsProcessed++;
            log(`üìè Processed row ${rowData.y} with ${rowData.stops.length} color stops`);
        }
        
        function onColumnProcessCallback(columnData) {
            totalColumnsProcessed++;
            log(`üìê Processed column ${columnData.x} with ${columnData.stops.length} color stops`);
        }
        
        function applyBaseGradient(cssResult) {
            // cssResult should be the full CSS string, we need to extract just the gradient
            let gradientValue = cssResult;
            
            // If it's a full CSS rule, extract just the background value
            if (cssResult.includes('background:')) {
                const match = cssResult.match(/background:\s*([^;]+)/);
                if (match) {
                    gradientValue = match[1].trim();
                }
            }
            
            document.getElementById('layerBase').style.background = gradientValue;
            document.getElementById('layerBaseEnhanced').style.background = gradientValue;
            log(`üé® Applied base gradient: ${gradientValue.substring(0, 100)}...`);
        }
        
        function generateToneMasksFromCallbackData() {
            // Use display dimensions for proper alignment
            const displayWidth = originalImageData.width;
            const displayHeight = originalImageData.height;
            
            // Create mask canvases at display resolution
            const specularMask = createMaskFromPixels(specularPixels, displayWidth, displayHeight);
            const reflectionMask = createMaskFromPixels(reflectionPixels, displayWidth, displayHeight);
            const shadowMask = createMaskFromPixels(shadowPixels, displayWidth, displayHeight);
            
            log(`üé≠ Generated masks: ${specularPixels.length} specular, ${reflectionPixels.length} reflection, ${shadowPixels.length} shadow pixels`);
            
            return {
                specular: specularMask,
                reflection: reflectionMask,
                shadow: shadowMask
            };
        }
        
        function createMaskFromPixels(pixels, width, height) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = width;
            canvas.height = height;
            
            // Create ImageData for the mask
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            
            // Fill with black (no mask)
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 0;     // R
                data[i + 1] = 0; // G
                data[i + 2] = 0; // B
                data[i + 3] = 255; // A
            }
            
            if (pixels.length === 0) {
                ctx.putImageData(imageData, 0, 0);
                return canvas.toDataURL();
            }
            
            // Re-analyze the original image data to create proper masks
            // This ensures masks match the actual image content, not just gradient sampling points
            if (originalImageData) {
                const originalData = originalImageData.data;
                const originalWidth = originalImageData.width;
                const originalHeight = originalImageData.height;
                
                // Scale factor between original image and mask
                const scaleX = originalWidth / width;
                const scaleY = originalHeight / height;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        // Sample from original image
                        const origX = Math.floor(x * scaleX);
                        const origY = Math.floor(y * scaleY);
                        const origIndex = (origY * originalWidth + origX) * 4;
                        
                        if (origIndex < originalData.length - 3) {
                            const r = originalData[origIndex];
                            const g = originalData[origIndex + 1];
                            const b = originalData[origIndex + 2];
                            
                            // Convert to grayscale for tone analysis
                            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                            
                            // Apply same thresholds as in callback
                            const specularThreshold = 200; // Lowered to catch more highlights
                            const shadowThreshold = 80;
                            
                            let maskValue = 0;
                            
                            // Determine mask value for this pixel
                            // For CSS masks: white = effect applied, black = effect masked out
                            // All masks must be completely filled (no transparency)
                            
                            if (pixels === specularPixels) {
                                if (gray >= specularThreshold) {
                                    // Bright areas = reduced contrast white mask (50% less harsh)
                                    maskValue = 127 + Math.round((gray - specularThreshold) / (255 - specularThreshold) * 64);
                                } else {
                                    // Non-bright areas = reduced contrast black mask
                                    maskValue = Math.round(gray / specularThreshold * 127);
                                }
                            } else if (pixels === shadowPixels) {
                                if (gray <= shadowThreshold) {
                                    // Dark areas = reduced contrast white mask (50% less harsh)
                                    maskValue = 127 + Math.round((shadowThreshold - gray) / shadowThreshold * 64);
                                } else {
                                    // Non-dark areas = reduced contrast black mask
                                    maskValue = Math.round((255 - gray) / (255 - shadowThreshold) * 127);
                                }
                            } else if (pixels === reflectionPixels) {
                                if (gray > shadowThreshold && gray < specularThreshold) {
                                    // Mid-tones = reduced contrast mask (50% less harsh)
                                    const midGray = 127.5;
                                    const distance = Math.abs(gray - midGray);
                                    const intensity = 1 - (distance / midGray);
                                    maskValue = Math.round(127 + (intensity * 64)); // 50% contrast reduction
                                } else {
                                    // Non-mid-tone areas = reduced contrast black mask
                                    maskValue = 64; // Not pure black, softer transition
                                }
                            }
                            
                            const maskIndex = (y * width + x) * 4;
                            data[maskIndex] = maskValue;     // R
                            data[maskIndex + 1] = maskValue; // G
                            data[maskIndex + 2] = maskValue; // B
                            data[maskIndex + 3] = 255;       // A
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            return canvas.toDataURL();
        }
        
        function applyEnhancedLayers(masks) {
            const demo = document.getElementById('enhancedDemo');
            
            // Save masks for invert toggles
            toneMaskData = masks;
            
            // Display mask previews
            displayMaskPreview('specularMaskCanvas', masks.specular);
            displayMaskPreview('reflectionMaskCanvas', masks.reflection);
            displayMaskPreview('shadowMaskCanvas', masks.shadow);
            
            // Apply masks to the gradient elements inside each layer
            const specularGradient = document.getElementById('specularGradient');
            const reflectionGradient = document.getElementById('reflectionGradient');
            const shadowGradient = document.getElementById('shadowGradient');
            
            if (specularGradient) {
                specularGradient.style.webkitMask = `url("${masks.specular}")`;
                specularGradient.style.mask = `url("${masks.specular}")`;
            }
            
            if (reflectionGradient) {
                reflectionGradient.style.webkitMask = `url("${masks.reflection}")`;
                reflectionGradient.style.mask = `url("${masks.reflection}")`;
            }
            
            if (shadowGradient) {
                shadowGradient.style.webkitMask = `url("${masks.shadow}")`;
                shadowGradient.style.mask = `url("${masks.shadow}")`;
            }
            
            // Apply initial effect colors and opacities
            updateEffects();
            
            log('‚ú® Applied enhanced tone layers with perfect alignment using shader structure!');
        }
        
        function updateEffects() {
            // Update slider value displays
            document.getElementById('specularOpacityValue').textContent = document.getElementById('specularOpacity').value;
            document.getElementById('reflectionOpacityValue').textContent = document.getElementById('reflectionOpacity').value;
            document.getElementById('shadowOpacityValue').textContent = document.getElementById('shadowOpacity').value;
            
            // Get color and opacity values
            const specularColor1 = document.getElementById('specularColor1').value;
            const specularColor2 = document.getElementById('specularColor2').value;
            const specularOpacity = document.getElementById('specularOpacity').value;
            const reflectionColor1 = document.getElementById('reflectionColor1').value;
            const reflectionColor2 = document.getElementById('reflectionColor2').value;
            const reflectionOpacity = document.getElementById('reflectionOpacity').value;
            const shadowColor1 = document.getElementById('shadowColor1').value;
            const shadowColor2 = document.getElementById('shadowColor2').value;
            const shadowOpacity = document.getElementById('shadowOpacity').value;
            
            // Get blend mode values
            const specularBlendMode = document.getElementById('specularBlendMode').value;
            const reflectionBlendMode = document.getElementById('reflectionBlendMode').value;
            const shadowBlendMode = document.getElementById('shadowBlendMode').value;
            
            // Convert hex colors to RGB
            const specularRGB1 = hexToRgb(specularColor1);
            const specularRGB2 = hexToRgb(specularColor2);
            const reflectionRGB1 = hexToRgb(reflectionColor1);
            const reflectionRGB2 = hexToRgb(reflectionColor2);
            const shadowRGB1 = hexToRgb(shadowColor1);
            const shadowRGB2 = hexToRgb(shadowColor2);
            
            // Update gradients and blend modes
            const specularLayer = document.getElementById('layerToneSpecular');
            const reflectionLayer = document.getElementById('layerToneReflection');
            const shadowLayer = document.getElementById('layerToneShadow');
            const specularGradient = document.getElementById('specularGradient');
            const reflectionGradient = document.getElementById('reflectionGradient');
            const shadowGradient = document.getElementById('shadowGradient');
            
            if (specularLayer && specularGradient) {
                const gradientCSS = `radial-gradient(circle, rgba(${specularRGB1.r},${specularRGB1.g},${specularRGB1.b},${specularOpacity}) 0%, rgba(${specularRGB2.r},${specularRGB2.g},${specularRGB2.b},${specularOpacity * 0.6}) 60%, transparent 100%)`;
                specularGradient.style.background = gradientCSS;
                specularLayer.style.mixBlendMode = specularBlendMode;
            }
            
            if (reflectionLayer && reflectionGradient) {
                const gradientCSS = `linear-gradient(135deg, rgba(${reflectionRGB1.r},${reflectionRGB1.g},${reflectionRGB1.b},${reflectionOpacity}) 0%, rgba(${reflectionRGB2.r},${reflectionRGB2.g},${reflectionRGB2.b},${reflectionOpacity * 0.5}) 50%, rgba(${reflectionRGB1.r},${reflectionRGB1.g},${reflectionRGB1.b},${reflectionOpacity * 0.8}) 100%)`;
                reflectionGradient.style.background = gradientCSS;
                reflectionLayer.style.mixBlendMode = reflectionBlendMode;
            }
            
            if (shadowLayer && shadowGradient) {
                const gradientCSS = `linear-gradient(to bottom, rgba(${shadowRGB1.r},${shadowRGB1.g},${shadowRGB1.b},${shadowOpacity * 0.3}) 0%, rgba(${shadowRGB2.r},${shadowRGB2.g},${shadowRGB2.b},${shadowOpacity}) 100%)`;
                shadowGradient.style.background = gradientCSS;
                shadowLayer.style.mixBlendMode = shadowBlendMode;
            }
            
            log(`üé® Updated effects: Specular ${specularColor1}-${specularColor2}@${specularOpacity} (${specularBlendMode}), Reflection ${reflectionColor1}-${reflectionColor2}@${reflectionOpacity} (${reflectionBlendMode}), Shadow ${shadowColor1}-${shadowColor2}@${shadowOpacity} (${shadowBlendMode})`);
        }
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        function toggleInvert(maskType) {
            maskInvertStates[maskType] = !maskInvertStates[maskType];
            const button = document.getElementById(`${maskType}Invert`);
            
            if (maskInvertStates[maskType]) {
                button.classList.add('active');
                button.textContent = 'Inverted';
            } else {
                button.classList.remove('active');
                button.textContent = 'Invert';
            }
            
            // Regenerate and apply masks with new invert state
            if (originalImageData && toneMaskData) {
                const masks = generateToneMasksFromCallbackData();
                applyMasksWithInvertStates(masks);
            }
            
            log(`üîÑ Toggled ${maskType} mask invert: ${maskInvertStates[maskType] ? 'ON' : 'OFF'}`);
        }
        
        async function applyMasksWithInvertStates(masks) {
            // Apply inverted masks where needed
            const specularMask = maskInvertStates.specular ? await invertMask(masks.specular) : masks.specular;
            const reflectionMask = maskInvertStates.reflection ? await invertMask(masks.reflection) : masks.reflection;
            const shadowMask = maskInvertStates.shadow ? await invertMask(masks.shadow) : masks.shadow;
            
            // Display mask previews
            displayMaskPreview('specularMaskCanvas', specularMask);
            displayMaskPreview('reflectionMaskCanvas', reflectionMask);
            displayMaskPreview('shadowMaskCanvas', shadowMask);
            
            // Apply to gradient elements
            const specularGradient = document.getElementById('specularGradient');
            const reflectionGradient = document.getElementById('reflectionGradient');
            const shadowGradient = document.getElementById('shadowGradient');
            
            if (specularGradient) {
                specularGradient.style.webkitMask = `url("${specularMask}")`;
                specularGradient.style.mask = `url("${specularMask}")`;
            }
            
            if (reflectionGradient) {
                reflectionGradient.style.webkitMask = `url("${reflectionMask}")`;
                reflectionGradient.style.mask = `url("${reflectionMask}")`;
            }
            
            if (shadowGradient) {
                shadowGradient.style.webkitMask = `url("${shadowMask}")`;
                shadowGradient.style.mask = `url("${shadowMask}")`;
            }
        }
        
        function invertMask(maskDataUrl) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Invert each pixel
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = 255 - data[i];         // R
                        data[i + 1] = 255 - data[i + 1]; // G
                        data[i + 2] = 255 - data[i + 2]; // B
                        // Keep alpha the same
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    resolve(canvas.toDataURL());
                };
                img.src = maskDataUrl;
            });
        }
        
        function displayMaskPreview(canvasId, maskDataUrl) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            const img = new Image();
            img.onload = function() {
                const scale = Math.min(200 / img.width, 150 / img.height);
                canvas.width = img.width * scale;
                canvas.height = img.height * scale;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            };
            img.src = maskDataUrl;
        }
        
        function updateStats() {
            const specularPercentage = ((specularPixels.length / totalPixelsProcessed) * 100).toFixed(2);
            const reflectionPercentage = ((reflectionPixels.length / totalPixelsProcessed) * 100).toFixed(2);
            const shadowPercentage = ((shadowPixels.length / totalPixelsProcessed) * 100).toFixed(2);
            
            const statsHtml = `
                <div class="stat-item"><span>Total Pixels Processed:</span><span>${totalPixelsProcessed.toLocaleString()}</span></div>
                <div class="stat-item"><span>Rows Processed:</span><span>${totalRowsProcessed}</span></div>
                <div class="stat-item"><span>Columns Processed:</span><span>${totalColumnsProcessed}</span></div>
                <div class="stat-item"><span>Specular Pixels:</span><span>${specularPixels.length.toLocaleString()} (${specularPercentage}%)</span></div>
                <div class="stat-item"><span>Reflection Pixels:</span><span>${reflectionPixels.length.toLocaleString()} (${reflectionPercentage}%)</span></div>
                <div class="stat-item"><span>Shadow Pixels:</span><span>${shadowPixels.length.toLocaleString()} (${shadowPercentage}%)</span></div>
                <div class="stat-item"><span>Perfect Alignment:</span><span>‚úÖ Guaranteed (same sampling points)</span></div>
            `;
            document.getElementById('statsContent').innerHTML = statsHtml;
        }
        
        function toggleLayer(layerId) {
            const layer = document.getElementById(layerId);
            const button = event.target;
            
            if (layer.style.display === 'none') {
                layer.style.display = 'block';
                button.classList.remove('disabled');
            } else {
                layer.style.display = 'none';
                button.classList.add('disabled');
            }
        }
        
        log('üîß Plugin system ready! Load an image to test the callback system.');
    </script>
</body>
</html>